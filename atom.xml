<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梁大红的技术Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liangdahong.com/"/>
  <updated>2018-08-08T05:16:37.000Z</updated>
  <id>https://liangdahong.com/</id>
  
  <author>
    <name>梁大红</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 之 init 构造方法</title>
    <link href="https://liangdahong.com/2018/08/08/2018/Swift-%E4%B9%8B-init-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>https://liangdahong.com/2018/08/08/2018/Swift-之-init-构造方法/</id>
    <published>2018-08-08T03:54:09.000Z</published>
    <updated>2018-08-08T05:16:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在我们刚刚接触 <code>Swift</code> 时，可能会遇到 <code>init 构造方法</code> 的各种坑，各种报错，那么 <code>Apple</code> 为什么要这样做呢？难道是无聊虐开发者吗？当然不是，其实我们在使用 <code>Objective-C</code> 编码时，对于新手来说太多坑了，比如：在 <code>init</code> 中调各种方法，访问各种属性等，在 <code>Objective-C</code> 中其实 <code>Apple</code> 是不推荐在 <code>init</code> 中访问属性的，因为此时可能部分属性根本没有初始化，可能导致一系列的问题存在。到了 <code>Swift</code> 时，<code>Apple</code> 做了强制措施，彻底解决类似的问题。</p></blockquote><a id="more"></a><blockquote><p><code>Apple</code> 在 <code>Swift</code> 中的 <code>init</code> 方法做各种限制的终极目标就是为了 <code>保证使用者不关使用什么方式创建对象，均保证在初始化完成前所有的属性都被初始化</code>，明白这目的时，对 <code>Swift</code> 的 <code>init</code> 就比较好理解了,具体的可以参考下面的文章，就不再一一分析了哈，逃.</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://swifter.tips/init-keywords/" target="_blank" rel="noopener">http://swifter.tips/init-keywords/</a></li><li><a href="https://www.jianshu.com/p/b1ab25ab00c1" target="_blank" rel="noopener">https://www.jianshu.com/p/b1ab25ab00c1</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在我们刚刚接触 &lt;code&gt;Swift&lt;/code&gt; 时，可能会遇到 &lt;code&gt;init 构造方法&lt;/code&gt; 的各种坑，各种报错，那么 &lt;code&gt;Apple&lt;/code&gt; 为什么要这样做呢？难道是无聊虐开发者吗？当然不是，其实我们在使用 &lt;code&gt;Objective-C&lt;/code&gt; 编码时，对于新手来说太多坑了，比如：在 &lt;code&gt;init&lt;/code&gt; 中调各种方法，访问各种属性等，在 &lt;code&gt;Objective-C&lt;/code&gt; 中其实 &lt;code&gt;Apple&lt;/code&gt; 是不推荐在 &lt;code&gt;init&lt;/code&gt; 中访问属性的，因为此时可能部分属性根本没有初始化，可能导致一系列的问题存在。到了 &lt;code&gt;Swift&lt;/code&gt; 时，&lt;code&gt;Apple&lt;/code&gt; 做了强制措施，彻底解决类似的问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://liangdahong.com/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>正确高效使用 Google</title>
    <link href="https://liangdahong.com/2018/07/11/2018/%E6%AD%A3%E7%A1%AE%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8-Google/"/>
    <id>https://liangdahong.com/2018/07/11/2018/正确高效使用-Google/</id>
    <published>2018-07-11T03:30:49.000Z</published>
    <updated>2018-08-07T01:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><a id="more"></a><ul><li>文章来自 <strong>七年就是一辈子-李笑来</strong></li></ul><blockquote><p>研究这个词，在英文中是research，我把它理解为re-search，实际上各种语言是相通的，所谓re-search其实就是“反复搜索”，就是“上下求索”（路漫漫其修远兮，吾将上下而求索）。所以，如果你想学点什么，就要善于搜索。而在这个时代里，最好的搜索工具就是 Google。</p></blockquote><blockquote><p>搜索引擎之所以迷人，就是因为它就好像望远镜一样：</p></blockquote><blockquote><p>能让你看到你原本完全看不到的东西……</p></blockquote><blockquote><p>互联网就好像那浩瀚的宇宙，里面几乎什么都有，只要你肯用“望远镜”去看、用搜索引擎去搜……</p></blockquote><blockquote><p>搜索引擎是公开的，人人都可以用的，可偏偏大多数人不用、不会用，甚至错误地用…… 于是人与人之间的差异多了另外一个不断延展的维度。在这个维度上你不如人家你能怪谁？</p></blockquote><blockquote><p>最烂的提问是：“我连不上 Google 怎么办呀？” 答案是“自己想办法” —— 如果你在乎，你就肯花时间自己解决这个问题，如果你不在乎，就不用在乎了。</p></blockquote><h2 id="使用“本尊”"><a href="#使用“本尊”" class="headerlink" title="使用“本尊”"></a>使用“本尊”</h2><p>最好使用 <a href="http://www.google.com/ncr" target="_blank" rel="noopener">http://www.google.com/ncr</a> NCR: No Country Redirection，而不是<a href="http://www.google.com.hk；有时，直接输入http://www.google.com也会被自动转到“本地Google”，比如，我用日本的" target="_blank" rel="noopener">http://www.google.com.hk；有时，直接输入http://www.google.com也会被自动转到“本地Google”，比如，我用日本的</a> VPN，浏览器就会把我转到<a href="http://www.google.co.jp……" target="_blank" rel="noopener">http://www.google.co.jp……</a></p><h2 id="优先使用英文关键字搜索"><a href="#优先使用英文关键字搜索" class="headerlink" title="优先使用英文关键字搜索"></a>优先使用英文关键字搜索</h2><p>这是个好习惯。别说不会英文，不会就学，没那么难。</p><h2 id="基本技巧"><a href="#基本技巧" class="headerlink" title="基本技巧"></a>基本技巧</h2><p>Google 搜索引擎也许是世界上最简单的应用界面，只有一个输入框和一个按钮。然而，用好它还是需要花点时间去学习的。Google 有帮助文档，还专门设计了个学习网站 A Google A Day</p><h3 id="加号"><a href="#加号" class="headerlink" title="加号"></a>加号</h3><p>在 Google 的输入框里，所有的空格都被 Google 理解为加号+。如果你输入的是 purpose of education那么 Google 返回的文章里既有“purpose”存在，也有“education”存在，但不一定有“purpose of education”存在。另外，过分常用的、单独存在没有意义的词汇往往被忽略掉，比如冠词“a”、“the”；介词“of”、“in”、“on”、“at”、“to”；连词“and”、“or”、“but”；从属连词“that”、“which”、“when”；代词“my”、“his”、“them”等等。</p><h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><p>如果你想要找含有“purpose of education”这个词组的文章，那么你必须输入”purpose of education”。现在的 Google 已经可以处理 utf-8 大字符集了，所以，即便你在输入的时候使用的是全角字符（不是半角字符的”而是“或者”）Google也照样能够正确处理。比较一下两种输入返回的结果：purpose of education vs.“purpose of education”。再试试 the most important benefit of education 和 “the most important benefit of education”。这就是引号（“……”）的作用——返回“完整匹配”的结果。</p><h3 id="减号"><a href="#减号" class="headerlink" title="减号"></a>减号</h3><p>为了进一步筛选搜索结果，还需要学会另外一个符号——减号-。比如，“the most important benefit of education” – “united states”要求Google返回含有“the most important benefit of education”但不存在“united states”的文章。</p><h3 id="星号"><a href="#星号" class="headerlink" title="星号"></a>星号</h3><p>另外一个威力无穷的符号是星号<em>。Google 支持通配符搜索，即搜索字符串中可以包含星号</em>，用来替代任意字符串。比如，“the most * examples of censorship”将会返回含有类似“the most outrageous examples of censorship”、“the most brazen examples of censorship”、“the most heinous examples of censorship”、“the most stupidest examples of censorship”、“the most dangerous examples of censorship”、“the most egregious examples of censorship”、“the most prolific examples of censorship”、“the most absurd examples of censorship”……</p><h3 id="波浪号"><a href="#波浪号" class="headerlink" title="波浪号"></a>波浪号</h3><p>还有一个运用相当灵活、经常带来意外收获的符号是波浪号~。把波浪号~加在某个单词前面，是在告诉 Google：除了给出的关键字之外，还要搜索与波浪号~后面的那个单词相关的词汇。比如，搜索the importance of ~censorship的结果中包含着“the importance of censorship”，也包含着与censorship相关的另外一个词汇“propaganda”——“the importance of propaganda”。</p><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h3><p>再学一个在指定网站中搜索的语法“site:”。比如，“the purpose of education” site:<a href="http://www.time.com/就是要求" target="_blank" rel="noopener">http://www.time.com/就是要求</a> Google 只返回 <a href="http://www.time.com" target="_blank" rel="noopener">http://www.time.com</a> 这个网站里的含有“the purpose of education”的文章。</p><h3 id="定制搜索"><a href="#定制搜索" class="headerlink" title="定制搜索"></a>定制搜索</h3><p>2006年，Google 推出了“co-op”服务（自定义搜索引擎）。其中最常用的功能之一就是可以指定 Google 搜索一个或者若干个指定的网站——相当于前面提到的 Google 语法“site:”的扩展。比如，我就曾经为我的学生定制了一个 Google cse（Custom Search Engine）——Search News Media。不妨看看在这个自定义搜索引擎上搜索censorship返回的结果（GRE/SAT 的作文考试中，都有很多关于“censorship”的作文题）。这个 cse 只搜索以下10个网站：</p><ul><li><a href="http://www.economist.com/" target="_blank" rel="noopener">http://www.economist.com/</a></li><li><a href="http://www.cnn.com/" target="_blank" rel="noopener">http://www.cnn.com/</a></li><li><a href="http://www.time.com/" target="_blank" rel="noopener">http://www.time.com/</a></li><li><a href="http://nytimes.com/" target="_blank" rel="noopener">http://nytimes.com/</a></li><li><a href="http://www.washingtonpost.com/" target="_blank" rel="noopener">http://www.washingtonpost.com/</a></li><li><a href="http://www.usnews.com/" target="_blank" rel="noopener">http://www.usnews.com/</a></li><li><a href="http://usatoday.com/" target="_blank" rel="noopener">http://usatoday.com/</a></li><li><a href="http://www.reuters.com/" target="_blank" rel="noopener">http://www.reuters.com/</a></li><li><a href="http://www.bbc.co.uk/" target="_blank" rel="noopener">http://www.bbc.co.uk/</a></li><li><a href="http://en.wikinews.org/" target="_blank" rel="noopener">http://en.wikinews.org/</a></li></ul><h2 id="特别声明"><a href="#特别声明" class="headerlink" title="特别声明"></a>特别声明</h2><ul><li>文章来自 <strong>七年就是一辈子-李笑来</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;
    
    </summary>
    
      <category term="效率" scheme="https://liangdahong.com/categories/%E6%95%88%E7%8E%87/"/>
    
    
  </entry>
  
  <entry>
    <title>转 - 中国教育问题的根源在于大学而不在高中</title>
    <link href="https://liangdahong.com/2018/06/25/%E8%BD%AC%E8%BD%BD/%E8%BD%AC-%E4%B8%AD%E5%9B%BD%E6%95%99%E8%82%B2%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90%E5%9C%A8%E4%BA%8E%E5%A4%A7%E5%AD%A6%E8%80%8C%E4%B8%8D%E5%9C%A8%E9%AB%98%E4%B8%AD/"/>
    <id>https://liangdahong.com/2018/06/25/转载/转-中国教育问题的根源在于大学而不在高中/</id>
    <published>2018-06-25T09:17:40.000Z</published>
    <updated>2018-08-06T09:32:10.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>文章转载自 <a href="https://mp.weixin.qq.com/s/PJc-EPoYWCiIK06zngWBCw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PJc-EPoYWCiIK06zngWBCw</a>，特别推荐大家关注此公众号。</li></ul><a id="more"></a><p><img src="http://p9mracz1h.bkt.clouddn.com/zgdxgywt.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;文章转载自 &lt;a href=&quot;https://mp.weixin.qq.com/s/PJc-EPoYWCiIK06zngWBCw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/PJc-EPoYWCiIK06zngWBCw&lt;/a&gt;，特别推荐大家关注此公众号。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="转载" scheme="https://liangdahong.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS 入门之一</title>
    <link href="https://liangdahong.com/2018/06/13/2018/CSS-%E5%85%A5%E9%97%A8%E4%B9%8B%E4%B8%80/"/>
    <id>https://liangdahong.com/2018/06/13/2018/CSS-入门之一/</id>
    <published>2018-06-13T09:08:17.000Z</published>
    <updated>2018-08-06T09:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS布局入门之一"><a href="#CSS布局入门之一" class="headerlink" title="CSS布局入门之一"></a>CSS布局入门之一</h1><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><blockquote><p>display: flex;</p></blockquote><a id="more"></a><ol><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">阮一峰 - Flex 布局教程：语法篇</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">阮一峰 - Flex 布局教程：实例篇</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes" target="_blank" rel="noopener">mozilla.org - 使用 CSS 弹性盒子</a></li></ol><h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><ul><li><p>flex-direction 主轴方向</p><pre><code>row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。</code></pre></li><li><p>flex-wrap 换行样式</p><pre><code>（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。</code></pre></li><li><p>flex-flow  <code>flex-direction</code>  和 <code>flex-wrap</code> 简写方式</p><pre><code>默认值为row nowrap</code></pre></li><li><p>justify-content 主轴对齐方式</p><pre><code>flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</code></pre></li><li><p>align-items     交叉轴/侧轴 对齐方式</p><pre><code>flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</code></pre></li><li><p>align-content   <code>多轴线时,一般是多条交叉轴时，多行项目就有多条交叉轴线</code>相当于<code>交叉轴</code>的<code>对齐方式</code>  是对全部的项目的对齐方式。</p><pre><code>flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。</code></pre></li></ul><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><ul><li><p>order</p><pre><code>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</code></pre></li></ul><ul><li><p>flex-grow属性</p><pre><code>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</code></pre></li></ul><ul><li><p>flex-shrink属性</p><pre><code>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</code></pre></li></ul><ul><li><p>flex-basis属性 (待理解)</p><pre><code>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</code></pre></li></ul><ul><li><p>flex属性</p><pre><code>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。  .item {    flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]  }  该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。  建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</code></pre></li></ul><ul><li><p>align-self属性</p><pre><code>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。.item {  align-self: auto | flex-start | flex-end | center | baseline | stretch;}该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</code></pre></li></ul><h2 id="position-定位"><a href="#position-定位" class="headerlink" title="position 定位"></a>position 定位</h2><p><a href="http://www.runoob.com/css/css-padding.html" target="_blank" rel="noopener">http://www.runoob.com/css/css-padding.html</a></p><blockquote><p>position 位置的意思，</p></blockquote><hr><ul><li>position: static   默认，   不会被定位，由上下文自动确定其位置</li><li>position: absolute 绝对定位，向上找到第一个 position 为 relative 的标签为参考，可以使用 top left right bottom 等属性</li><li>position: relative 相对定位，以自己为参考</li><li>position: fixed 固定定位</li></ul><h2 id="一些实例"><a href="#一些实例" class="headerlink" title="一些实例"></a>一些实例</h2><h3 id="单行文本框垂直居中"><a href="#单行文本框垂直居中" class="headerlink" title="单行文本框垂直居中"></a>单行文本框垂直居中</h3><ul><li>可以把其 [行高 line-height ] 设置为标签高度即可 <code>line-height: height;</code></li></ul><h3 id="多行文本框垂直居中"><a href="#多行文本框垂直居中" class="headerlink" title="多行文本框垂直居中"></a>多行文本框垂直居中</h3><ul><li>可以使用 table 和 table-cell </li><li>参考 <a href="https://www.cnblogs.com/xiaofeixiang/p/5005587.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.cnblogs.com/xiaofeixiang/p/5005587.html?utm_source=tuicool&amp;utm_medium=referral</a></li></ul><h2 id="CSS样式类型"><a href="#CSS样式类型" class="headerlink" title="CSS样式类型"></a>CSS样式类型</h2><ul><li>标签</li><li>类</li><li>id</li><li>通配样式</li><li>交集</li><li>并集</li><li>子带</li><li>后带</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSS布局入门之一&quot;&gt;&lt;a href=&quot;#CSS布局入门之一&quot; class=&quot;headerlink&quot; title=&quot;CSS布局入门之一&quot;&gt;&lt;/a&gt;CSS布局入门之一&lt;/h1&gt;&lt;h2 id=&quot;flex&quot;&gt;&lt;a href=&quot;#flex&quot; class=&quot;headerlink&quot; title=&quot;flex&quot;&gt;&lt;/a&gt;flex&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;display: flex;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Web" scheme="https://liangdahong.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈 iOS 事件的传递和响应过程</title>
    <link href="https://liangdahong.com/2018/06/08/2018/%E6%B5%85%E8%B0%88-iOS-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B/"/>
    <id>https://liangdahong.com/2018/06/08/2018/浅谈-iOS-事件的传递和响应过程/</id>
    <published>2018-06-08T03:16:11.000Z</published>
    <updated>2018-08-07T09:12:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote></blockquote><ul><li><code>iOS</code> 中 <code>View</code> 的事件到底是怎么<code>传递</code>和<code>响应</code>的？</li><li>为什么 <code>父View</code> 关闭了事件响应时，<code>子View</code> 就无法响应事件？ 底层原理？</li><li>如何扩大 <code>Button</code> 的点击范围 ？</li><li>如何让 <code>父View</code> 和 <code>子View</code> 同时响应同一事件？默认情况下只会响应 <code>子View</code> 的事件回调。</li><li>为什么 <code>子View</code> 关闭了事件，但其 <code>父View</code> 开启事件的情况下，点击 <code>子View</code> 时，<code>父View</code> 可以正常响应事件？</li><li>为什么 子View 是 UIView时，如果没有添加手势，点击子 View时，会由其父View来响应，而 子View 是 UIControl 时，子View 没有添加手势，一样不会由 父View 来响应</li><li>…</li></ul><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p><code>iOS</code> 的事件可以分为三种</p></blockquote><ul><li><code>Touch Events(触摸事件)</code></li><li><code>Motion Events(运动事件，比如重力感应和摇一摇等)</code></li><li><code>Remote Events(远程事件，比如用耳机上得按键来控制手机)</code></li></ul><blockquote><p>下面主要讲解 <code>Touch Events(触摸事件)</code> <code>Touch Events</code>事件的整个过程可以分为 <code>传递</code>和<code>响应</code> 2 个阶段，</p><ul><li>传递： 是当我们触摸屏幕时，为我们找出最适合的 <code>View</code>，</li><li>响应： 当我们找出最适合的 <code>View</code> 后，此时只是找到了最合适的 <code>View</code>，但未必 此 <code>View</code> 可以响应此事件，所以需要继续找出能响应此事件的 <code>View</code>。</li></ul></blockquote><h3 id="传递过程"><a href="#传递过程" class="headerlink" title="传递过程"></a>传递过程</h3><blockquote><p>每当手指接触屏幕，操作系统会把事件传递给当前的 <code>App</code>， 在 <code>UIApplication</code>接收到手指的事件之后，就会去调用`UIWindow的hitTest:withEvent:，看看当前点击的点是不是在window内，如果是则继续依次调用其 subView的hitTest:withEvent:方法，直到找到最后需要的view。调用结束并且hit-test view确定之后，便可以确定最合适的 View。</p></blockquote><ul><li>引用几张图来说明</li></ul><p><img src="https://zhoon.github.io/img/artical/ios_event/iosevent_3.png" alt=""></p><p><img src="https://zhoon.github.io/img/artical/ios_event/iosevent_4.png" alt=""></p><p><img src="https://zhoon.github.io/img/artical/ios_event/iosevent_5.png" alt=""></p><ul><li>图片表示的内容可用下面的话描述<a href="https://zhoon.github.io/ios/2015/04/12/ios-event.html" target="_blank" rel="noopener">来自这里</a></li></ul><blockquote><p>递归是向界面的根节点UIWindow发送hitTest:withEvent:消息开始的，从这个消息返回的是一个UIView，也就是手指当前位置最前面的那个 hittest view。 当向UIWindow发送hitTest:withEvent:消息时，hitTest:withEvent:里面所做的事，就是判断当前的点击位置是否在window里面，如果在则遍历window的subview然后依次对subview发送hitTest:withEvent:消息(注意这里给subview发送消息是根据当前subview的index顺序，index越大就越先被访问)。如果当前的point没有在view上面，那么这个view的subview也就不会被遍历了。当事件遍历到了view B.1，发现point在view B.1里面，并且view B.1没有subview，那么他就是我们要找的hittest view了，找到之后就会一路返回直到根节点，而view B之后的view A也不会被遍历了。</p></blockquote><ul><li>下面是 <code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</code> 方法的内部实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    if (self.hidden || !self.userInteractionEnabled || self.alpha &lt; 0.01 || ![self pointInside:point withEvent:event] || ![self _isAnimatedUserInteractionEnabled]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123;</span><br><span class="line">            UIView *hitView = [subview hitTest:[subview convertPoint:point fromView:self] withEvent:event];</span><br><span class="line">            if (hitView) &#123;</span><br><span class="line">                return hitView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return self;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/BigZaphod/Chameleon/blob/master/UIKit/Classes/UIView.m" target="_blank" rel="noopener">上面的代码来自这里</a></p></blockquote><h3 id="响应过程"><a href="#响应过程" class="headerlink" title="响应过程"></a>响应过程</h3><ul><li>个人对响应过程的理解如下： </li></ul><blockquote><p>当我们知道最合适的 View 后，事件会 由上向下【子view -&gt; 父view，控制器view -&gt; 控制器】来找出合适响应事件的 View，来响应相关的事件。如果当前的 View 有添加手势，那么直接响应相应的事件，不会继续向下寻找了，如果没有手势事件，那么会看其是否实现了如下的方法：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure><hr><p>如果有实现那么就由此 View 响应，如果没有实现，那么就会传递给他的下一个响应者【子view -&gt; 父view，控制器view -&gt; 控制器】， 这里我们可以做一个简单的验证，在默认情况下 UIView 是不响应事件的，UIControl 就算没有添加手势一样的会由他来响应， 这里可以使用 runtime查看 UIView 和 UIControl 的方法列表， 或 查看 <a href="https://github.com/BigZaphod/Chameleon/blob/master/UIKit/Classes/UIView.m" target="_blank" rel="noopener">UIKit 源码</a> 可知， UIView 没有实现如上的 <code>touchesBegan</code>方法，而 <code>UIControl</code> 是实现了如上的相关方法，所以验证了刚才的 UIView 不响应，和 UIControl 的响应。一旦找到最合适响应的View就结束, 在执行响应的绑定的事件，如果没有就抛弃此事件。</p><p>我的验证</p><ul><li>首先处理添加了手势时，其便可以处理事件。</li><li>我们创建一个view A 在 A 中添加一个 view B, 如果我们给 A 加了手势，B没有加手势，</li><li>我们在点击 B 时，会响应 A 的事件，非常正常的情况，那么它是怎么判断 B 是否可以处理的呢？</li><li>我们现在给 B 加一个手势，那么同样的操作时会触发 B 的手势，现在我们 给 B 增加一个方法，</li></ul><pre><code class="c">@implementation BMSonView- (NSArray&lt;UIGestureRecognizer *&gt; *)gestureRecognizers {    NSLog(@<span class="string">"%@"</span>, self);    <span class="keyword">return</span> @[];}</code></pre><blockquote><p>手势返回 @[]，此时点击 B 只会触发 A 的事件，由此可以说明在判断 view 是否可以处理事件实现是判断  gestureRecognizers  即是否添加了手势，上面提到了还有判断如下的方法是否实现了,默认情况下 UIView 是没有实现如下的方法的，使用在没有添加手势时他不响应事件。</p></blockquote><pre><code class="c">- (<span class="keyword">void</span>)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (<span class="keyword">void</span>)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (<span class="keyword">void</span>)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (<span class="keyword">void</span>)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</code></pre><p>如果我们手动实现了如上的方法时，就算没有给  B 添加手势，点击 B 时， 事件不会响应 A 的方法，会到上面的方法中。从 UIControl 的源码便可清除看到。</p><p>所以个人理解：</p><ul><li>事件在传递时和上面的 hit 方法有关，一层层向上传递，【窗口—&gt; view】由其相应的 view 中具体的实现来确定谁才是是最合适响应的view</li><li>在响应时，又上向下找出第一个能处理的view来处理事件，[view —&gt; 窗口]，在寻找刚过程中 会判断是否增加了手势 和是否实现了如上的 触摸方法。</li><li>至于 UIControl Button 的特殊事件相应，个人认为是在其m文件中实现了上面的4个方法，在这4个方法中做了相关的处理，这里可以从 UIControl 代码中在知道一些内容。</li><li>所以如果想自己实现 UIControl Button ，首先要想办法处理好上面的4个方法。</li></ul><ul><li>图如下<br><img src="https://zhoon.github.io/img/artical/ios_event/iosevent_2.png" alt=""></li></ul><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><ul><li><p>iOS 中 View 的事件到底是怎么传递和响应的？</p><blockquote><p>如上所描。</p></blockquote></li><li><p>为什么 父View 关闭了事件响应时，子View 就无法响应事件？</p><blockquote><p>因为在事件传递的时，先到父view，当父view无法响应事，直接就跳过了遍历其子view，故只要父类关闭了事件，子 view 就已经没有机会响应事件了。</p></blockquote></li></ul><ul><li><p>如何扩大 Button 的点击范围？</p><blockquote><p>扩大点击范围，无非就是想本来没有点击 btn 但想让 btn 响应事件，那么可以在 hitTest 方法中做适当的操作，当满足xxx条件时，强行返回 btn 来达到最佳点击范围的效果，相关的实现可以自行 Google ，有一些较优雅而简洁的方式。</p></blockquote></li><li><p>如何让 父View 和 子View 同时响应同一事件？</p><blockquote><p>父View 和 子View同时响应同一事件，默认当点击子view时，如果ziview可以处理事件，那么其他父view 是不会响应的，但是在 父view 传到 子view 时我们在 hitTest 方法中是清楚知道的，使用可以在这里做相关的操作便实现了子view 和父view 同时响应事件的效果。</p></blockquote></li><li><p>为什么子View 关闭了事件，但其 父View 开启事件的情况下，点击 子View 时，父View 可以响应事件？</p><blockquote><p>子view关闭了事件，事件的传递是 父view 到子view，在 父view时，父view可以响应，那么会继续访问其 子view是否可以响应，如果此时子view不可以响应，那么他会直接返回 父view，所以 子View 关闭了事件 父View  正常执行事件是必然的。</p></blockquote></li></ul><ul><li><p>为什么 子View 是 UIView时，如果没有添加手势，点击子 View时，会由其父View来响应，而 子View 是 UIControl 时，子View 没有添加手势，一样不会由 父View 来响应</p><blockquote><p>这个问题可以见上面的寻找可以响应的 view 来解决，UIControl 实现了如上的 4 大方法，而 UIView 没有实现。</p></blockquote></li><li><p>这里其实还有许多内容待挖掘，比如：scrollview 的事件响应等。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://smnh.me/hit-testing-in-ios/" target="_blank" rel="noopener">http://smnh.me/hit-testing-in-ios/</a></li><li><a href="https://zhoon.github.io/ios/2015/04/12/ios-event.html" target="_blank" rel="noopener">https://zhoon.github.io/ios/2015/04/12/ios-event.html</a></li><li><a href="http://southpeak.github.io/blog/2015/03/07/uiresponder/" target="_blank" rel="noopener">http://southpeak.github.io/blog/2015/03/07/uiresponder/</a></li><li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScrollView_Class/index.html#//apple_ref/doc/uid/TP40006922" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScrollView_Class/index.html#//apple_ref/doc/uid/TP40006922</a></li><li><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html</a></li><li><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2</a></li><li><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iOS&lt;/code&gt; 中 &lt;code&gt;View&lt;/code&gt; 的事件到底是怎么&lt;code&gt;传递&lt;/code&gt;和&lt;code&gt;响应&lt;/code&gt;的？&lt;/li&gt;
&lt;li&gt;为什么 &lt;code&gt;父View&lt;/code&gt; 关闭了事件响应时，&lt;code&gt;子View&lt;/code&gt; 就无法响应事件？ 底层原理？&lt;/li&gt;
&lt;li&gt;如何扩大 &lt;code&gt;Button&lt;/code&gt; 的点击范围 ？&lt;/li&gt;
&lt;li&gt;如何让 &lt;code&gt;父View&lt;/code&gt; 和 &lt;code&gt;子View&lt;/code&gt; 同时响应同一事件？默认情况下只会响应 &lt;code&gt;子View&lt;/code&gt; 的事件回调。&lt;/li&gt;
&lt;li&gt;为什么 &lt;code&gt;子View&lt;/code&gt; 关闭了事件，但其 &lt;code&gt;父View&lt;/code&gt; 开启事件的情况下，点击 &lt;code&gt;子View&lt;/code&gt; 时，&lt;code&gt;父View&lt;/code&gt; 可以正常响应事件？&lt;/li&gt;
&lt;li&gt;为什么 子View 是 UIView时，如果没有添加手势，点击子 View时，会由其父View来响应，而 子View 是 UIControl 时，子View 没有添加手势，一样不会由 父View 来响应&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://liangdahong.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>转 - 优化 iOS 程序性能的 24 个方法</title>
    <link href="https://liangdahong.com/2018/05/23/%E8%BD%AC%E8%BD%BD/%E8%BD%AC-%E4%BC%98%E5%8C%96-iOS-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E7%9A%84-24-%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
    <id>https://liangdahong.com/2018/05/23/转载/转-优化-iOS-程序性能的-24-个方法/</id>
    <published>2018-05-22T16:33:30.000Z</published>
    <updated>2018-08-06T09:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用ARC管理内存"><a href="#用ARC管理内存" class="headerlink" title="用ARC管理内存"></a>用ARC管理内存</h2><ul><li><a href="http://www.codeceo.com/article/optimize-ios-program-performance.html" target="_blank" rel="noopener">转自 http://www.codeceo.com/article/optimize-ios-program-performance.html</a></li></ul><a id="more"></a><blockquote><p>ARC(Automatic ReferenceCounting, 自动引用计数)和iOS5一起发布，它避免了最常见的也就是经常是由于我们忘记释放内存所造成的内存泄露。它自动为你管理retain和release的过程，所以你就不必去手动干预了。忘掉代码段结尾的release简直像记得吃饭一样简单。而ARC会自动在底层为你做这些工作。除了帮你避免内存泄露，ARC还可以帮你提高性能，它能保证释放掉不再需要的对象的内存。</p></blockquote><blockquote><p>现在所有的iOS程序都用ARC了，这条可以忽略。</p></blockquote><h2 id="在正确的地方使用-reuseIdentifier"><a href="#在正确的地方使用-reuseIdentifier" class="headerlink" title="在正确的地方使用 reuseIdentifier"></a>在正确的地方使用 reuseIdentifier</h2><blockquote><p>一个开发中常见的错误就是没有给UITableViewCells， UICollectionViewCells，甚至是UITableViewHeaderFooterViews设置正确的reuseIdentifier。</p></blockquote><blockquote><p>为了性能最优化，table view用tableView:cellForRowAtIndexPath:为rows分配cells的时候，它的数据应该重用自UITableViewCell。一个table view维持一个队列的数据可重用的UITableViewCell对象。</p></blockquote><blockquote><p>不使用reuseIdentifier的话，每显示一行table view就不得不设置全新的cell。这对性能的影响可是相当大的，尤其会使app的滚动体验大打折扣。</p></blockquote><blockquote><p>自iOS6起，除了UICollectionView的cells和补充views，你也应该在header和footer views中使用reuseIdentifiers。</p></blockquote><blockquote><p>想要使用reuseIdentifiers的话，在一个table view中添加一个新的cell时在data source object中添加这个方法：</p></blockquote><pre><code>staticNSString *CellIdentifier = @&quot;Cell&quot;;  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath];</code></pre><blockquote><p>这个方法把那些已经存在的cell从队列中排除，或者在必要时使用先前注册的nib或者class创造新的cell。如果没有可重用的cell，你也没有注册一个class或者nib的话，这个方法返回nil。</p></blockquote><h2 id="尽量把views设置为透明"><a href="#尽量把views设置为透明" class="headerlink" title="尽量把views设置为透明"></a>尽量把views设置为透明</h2><blockquote><p>如果你有透明的Views你应该设置它们的opaque属性为YES。</p></blockquote><blockquote><p>原因是这会使系统用一个最优的方式渲染这些views。这个简单的属性在IB或者代码里都可以设定。</p></blockquote><blockquote><p>Apple的文档对于为图片设置透明属性的描述是：</p></blockquote><blockquote><p>(opaque)这个属性给渲染系统提供了一个如何处理这个view的提示。如果设为YES，渲染系统就认为这个view是完全不透明的，这使得渲染系统优化一些渲染过程和提高性能。如果设置为NO，渲染系统正常地和其它内容组成这个View。默认值是YES。</p></blockquote><blockquote><p>在相对比较静止的画面中，设置这个属性不会有太大影响。然而当这个view嵌在scroll view里边，或者是一个复杂动画的一部分，不设置这个属性的话会在很大程度上影响app的性能。</p></blockquote><blockquote><p>你可以在模拟器中用Debug\Color Blended Layers选项来发现哪些view没有被设置为opaque。目标就是，能设为opaque的就全设为opaque!</p></blockquote><blockquote><p>这里有一点需要注意，只要是有中文字符的Label，哪怕你设置成不透明，模拟器中这个Label依然会变红，这个猜测是字符绘制的时候出的问题，这个目前没找到好的解决方法。</p></blockquote><h2 id="避免过于庞大的XIB"><a href="#避免过于庞大的XIB" class="headerlink" title="避免过于庞大的XIB"></a>避免过于庞大的XIB</h2><blockquote><p>iOS5中加入的Storyboards(分镜)正在快速取代XIB。然而XIB在一些场景中仍然很有用。比如你的app需要适应iOS5之前的设备，或者你有一个自定义的可重用的view,你就不可避免地要用到他们。</p></blockquote><blockquote><p>如果你不得不XIB的话，使他们尽量简单。尝试为每个Controller配置一个单独的XIB，尽可能把一个View Controller的view层次结构分散到单独的XIB中去。</p></blockquote><blockquote><p>需要注意的是，当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。Storyboards就是另一码事儿了，storyboard仅在需要时实例化一个view controller.</p></blockquote><blockquote><p>当家在XIB是，所有图片都被chache，如果你在做OS X开发的话，声音文件也是。Apple在相关文档中的记述是：</p></blockquote><blockquote><p>当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。在OS X中，图片和声音资源被缓存在named cache中以便将来用到时获取。在iOS中，仅图片资源会被存进named caches。取决于你所在的平台，使用NSImage 或UIImage的imageNamed:方法来获取图片资源。</p></blockquote><blockquote><p>这个问题我深有体会，用xib写的界面加载速度比直接用代码写的要慢好多。</p></blockquote><h2 id="不要阻塞主线程"><a href="#不要阻塞主线程" class="headerlink" title="不要阻塞主线程"></a>不要阻塞主线程</h2><blockquote><p>永远不要使主线程承担过多。因为UIKit在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成。</p></blockquote><blockquote><p>一直使用主线程的风险就是如果你的代码真的block了主线程，你的app会失去反应。</p></blockquote><blockquote><p>大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。</p></blockquote><blockquote><p>你可以使用NSURLConnection异步地做网络操作:</p></blockquote><pre><code>+ (void)sendAsynchronousRequest:(NSURLRequest *)request queue:(NSOperationQueue*)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler</code></pre><blockquote><p>或者使用像AFNetworking这样的框架来异步地做这些操作。</p></blockquote><blockquote><p>如果你需要做其它类型的需要耗费巨大资源的操作(比如时间敏感的计算或者存储读写)那就用 Grand Central Dispatch，或者&gt;NSOperation和 NSOperationQueues.</p></blockquote><blockquote><p>下面代码是使用GCD的模板</p></blockquote><pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{      // switch to a background thread and perform your expensive operation      dispatch_async(dispatch_get_main_queue(), ^{          // switch back to the main thread to update your UI      });  });</code></pre><blockquote><p>发现代码中有一个嵌套的dispatch_async吗？这是因为任何UIKit相关的代码需要在主线程上进行。</p></blockquote><h2 id="在Image-Views中调整图片大小"><a href="#在Image-Views中调整图片大小" class="headerlink" title="在Image Views中调整图片大小"></a>在Image Views中调整图片大小</h2><blockquote><p>如果要在UIImageView中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的，特别是UIImageView嵌套在UIScrollView中的情况下。</p></blockquote><blockquote><p>如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background &gt;thread，缩放一次，然后在UIImageView中使用缩放后的图片。</p></blockquote><h2 id="选择正确的Collection"><a href="#选择正确的Collection" class="headerlink" title="选择正确的Collection"></a>选择正确的Collection</h2><blockquote><p>学会选择对业务场景最合适的类或者对象是写出能效高的代码的基础。当处理collections时这句话尤其正确。</p></blockquote><blockquote><p>一些常见collection的总结：</p></blockquote><blockquote><p>Arrays: 有序的一组值。使用index来lookup很快，使用value lookup很慢，插入/删除很慢。<br>Dictionaries: 存储键值对。用键来查找比较快。<br>Sets: 无序的一组值。用值来查找很快，插入/删除很快。因为Set用到了哈希，所以插入删除查找速度比Array快很多</p></blockquote><h2 id="打开gzip压缩"><a href="#打开gzip压缩" class="headerlink" title="打开gzip压缩"></a>打开gzip压缩</h2><blockquote><p>大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。</p></blockquote><blockquote><p>问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。</p></blockquote><blockquote><p>减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。</p></blockquote><blockquote><p>好消息是，iOS已经在NSURLConnection中默认支持了gzip压缩，当然AFNetworking这些基于它的框架亦然。像Google App Engine这些云服务提供者也已经支持了压缩输出。</p></blockquote><h2 id="重用和延迟加载-lazy-load-Views"><a href="#重用和延迟加载-lazy-load-Views" class="headerlink" title="重用和延迟加载(lazy load) Views"></a>重用和延迟加载(lazy load) Views</h2><blockquote><p>更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。</p></blockquote><blockquote><p>这里我们用到的技巧就是模仿UITableView和UICollectionView的操作:不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。</p></blockquote><blockquote><p>这样的话你就只需要在滚动发生时创建你的views，避免了不划算的内存分配。</p></blockquote><blockquote><p>创建views的能效问题也适用于你app的其它方面。想象一下一个用户点击一个按钮的时候需要呈现一个view的场景。有两种实现方法：</p></blockquote><ol><li><p>创建并隐藏这个view当这个screen加载的时候，当需要时显示它；</p></li><li><p>当需要时才创建并展示。</p></li></ol><blockquote><p>每个方案都有其优缺点。用第一种方案的话因为你需要一开始就创建一个view并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的app操作更敏感因为当用户点击按钮的时候它只需要改变一下这个view的可见性。</p></blockquote><blockquote><p>第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。</p></blockquote><h2 id="Cache-Cache-还是Cache-注意你的缓存"><a href="#Cache-Cache-还是Cache-注意你的缓存" class="headerlink" title="Cache, Cache, 还是Cache!注意你的缓存"></a>Cache, Cache, 还是Cache!注意你的缓存</h2><blockquote><p>一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。</p></blockquote><blockquote><p>我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。</p></blockquote><blockquote><p>NSURLConnection默认会缓存资源在内存或者存储中根据它所加载的HTTP Headers。你甚至可以手动创建一个NSURLRequest然后使它只加载缓存的值。</p></blockquote><blockquote><p>下面是一个可用的代码段，你可以可以用它去为一个基本不会改变的图片创建一个NSURLRequest并缓存它：</p></blockquote><pre><code>+ (NSMutableURLRequest *)imageRequestWithURL:(NSURL *)url {      NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];      request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;// this will make sure the request always returns the cached image      request.HTTPShouldHandleCookies = NO;      request.HTTPShouldUsePipelining = YES;      [request addValue:@&quot;image/*&quot;forHTTPHeaderField:@&quot;Accept&quot;];      return request;  }</code></pre><blockquote><p>注意你可以通过 NSURLConnection 获取一个URL request， AFNetworking也一样的。这样你就不必为采用这条tip而改变所有的networking代码了。</p></blockquote><blockquote><p>如果你需要缓存其它不是HTTP Request的东西，你可以用NSCache。</p></blockquote><blockquote><p>NSCache和NSDictionary类似，不同的是系统回收内存的时候它会自动删掉它的内容。</p></blockquote><h2 id="权衡渲染方法"><a href="#权衡渲染方法" class="headerlink" title="权衡渲染方法"></a>权衡渲染方法</h2><blockquote><p>在iOS中可以有很多方法做出漂亮的按钮。你可以用整幅的图片，可调大小的图片，或者可以用CALayer， CoreGraphics甚至OpenGL来画它们。当然每个不同的解决方法都有不同的复杂程度和相应的性能。</p></blockquote><blockquote><p>简单来说，就是用事先渲染好的图片更快一些，因为如此一来iOS就免去了创建一个图片再画东西上去然后显示在屏幕上的程序。问题是你需要把所有你需要用到的图片放到app的bundle里面，这样就增加了体积–这就是使用可变大小的图片更好的地方了:你可以省去一些不必要的空间，也不需要再为不同的元素(比如按钮)来做不同的图。</p></blockquote><blockquote><p>然而，使用图片也意味着你失去了使用代码调整图片的机动性，你需要一遍又一遍不断地重做他们，这样就很浪费时间了，而且你如果要做一个动画效果，虽然每幅图只是一些细节的变化你就需要很多的图片造成bundle大小的不断增大。</p></blockquote><blockquote><p>总得来说，你需要权衡一下利弊，到底是要性能能还是要bundle保持合适的大小。</p></blockquote><h2 id="处理内存警告"><a href="#处理内存警告" class="headerlink" title="处理内存警告"></a>处理内存警告</h2><blockquote><p>一旦系统内存过低，iOS会通知所有运行中app。在官方文档中是这样记述:</p></blockquote><blockquote><p>如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references.</p></blockquote><blockquote><p>幸运的是，UIKit提供了几种收集低内存警告的方法:</p></blockquote><blockquote><p>在app delegate中使用applicationDidReceiveMemoryWarning:的方法<br>在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning<br>注册并接收 UIApplicationDidReceiveMemoryWarningNotification的通知<br>一旦收到这类通知，你就需要释放任何不必要的内存使用。</p></blockquote><blockquote><p>例如，UIViewController的默认行为是移除一些不可见的view，它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。</p></blockquote><blockquote><p>这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。</p></blockquote><blockquote><p>然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。</p></blockquote><blockquote><p>当然，现在iOS设备运行内存越来越大，这一点很难出现了。</p></blockquote><h2 id="重用大开销对象"><a href="#重用大开销对象" class="headerlink" title="重用大开销对象"></a>重用大开销对象</h2><blockquote><p>一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。</p></blockquote><blockquote><p>想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。</p></blockquote><blockquote><p>注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。</p></blockquote><blockquote><p>下面的代码说明了使用一个属性来延迟加载一个date formatter. 第一次调用时它会创建一个新的实例，以后的调用则将返回已经创建的实例：</p></blockquote><pre><code>// in your .h or inside a class extension  @property (nonatomic, strong) NSDateFormatter *formatter;  // inside the implementation (.m)  // When you need, just use self.formatter  - (NSDateFormatter *)formatter {      if(!_formatter) {          _formatter = [[NSDateFormatter alloc] init];          _formatter.dateFormat = @&quot;EEE MMM dd HH:mm:ss Z yyyy&quot;;// twitter date format      }      return _formatter;  }</code></pre><blockquote><p>还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。</p></blockquote><h2 id="使用Sprite-Sheets"><a href="#使用Sprite-Sheets" class="headerlink" title="使用Sprite Sheets"></a>使用Sprite Sheets</h2><blockquote><p>Sprite sheet可以让渲染速度加快，甚至比标准的屏幕渲染方法节省内存。</p></blockquote><h2 id="避免反复处理数据"><a href="#避免反复处理数据" class="headerlink" title="避免反复处理数据"></a>避免反复处理数据</h2><blockquote><p>许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。在内存中操作数据使它们满足你的数据结构是开销很大的。</p></blockquote><blockquote><p>比如你需要数据来展示一个table view,最好直接从服务器取array结构的数据以避免额外的中间数据结构改变。</p></blockquote><blockquote><p>类似的，如果需要从特定key中取数据，那么就使用键值对的dictionary。</p></blockquote><blockquote><p>这一点在处理大量数据的时候极为重要，用空间换时间的方法也许是极好的。</p></blockquote><h2 id="选择正确的数据格式"><a href="#选择正确的数据格式" class="headerlink" title="选择正确的数据格式"></a>选择正确的数据格式</h2><blockquote><p>从app和网络服务间传输数据有很多方案，最常见的就是JSON和XML。你需要选择对你的app来说最合适的一个。</p></blockquote><blockquote><p>解析JSON会比XML更快一些，JSON也通常更小更便于传输。从iOS5起有了官方内建的JSON deserialization就更加方便使用了。</p></blockquote><blockquote><p>但是XML也有XML的好处，比如使用SAX来解析XML就像解析本地文件一样，你不需像解析json一样等到整个文档下载完成才开始解析。当&gt;你处理很大的数据的时候就会极大地减低内存消耗和增加性能。</p></blockquote><blockquote><p>现在基本上都是JSON了。</p></blockquote><h2 id="正确设定背景图片"><a href="#正确设定背景图片" class="headerlink" title="正确设定背景图片"></a>正确设定背景图片</h2><blockquote><p>在View里放背景图片就像很多其它iOS编程一样有很多方法:</p></blockquote><blockquote><p>使用UIColor的 colorWithPatternImage来设置背景色；</p></blockquote><blockquote><p>在view中添加一个UIImageView作为一个子View。</p></blockquote><blockquote><p>如果你使用全画幅的背景图，你就必须使用UIImageView因为UIColor的colorWithPatternImage是用来创建小的重复的图片作为背&gt;景的。这种情形下使用UIImageView可以节约不少的内存：</p></blockquote><pre><code>// You could also achieve the same result in Interface BuilderUIImageView *backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;background&quot;]];[self.view addSubview:backgroundView];</code></pre><blockquote><p>如果你用小图平铺来创建背景，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存：</p></blockquote><pre><code>self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@&quot;background&quot;]];</code></pre><h2 id="减少使用Web特性"><a href="#减少使用Web特性" class="headerlink" title="减少使用Web特性"></a>减少使用Web特性</h2><blockquote><p>UIWebView很有用，用它来展示网页内容或者创建UIKit很难做到的动画效果是很简单的一件事。</p></blockquote><blockquote><p>但是你可能有注意到UIWebView并不像驱动Safari的那么快。这是由于以JIT compilation为特色的Webkit的Nitro Engine的限制。</p></blockquote><blockquote><p>所以想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的JavaScript，避免使用过大的框架。能只用原生js就更好了。</p></blockquote><blockquote><p>另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。</p></blockquote><blockquote><p>最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。</p></blockquote><h2 id="设定Shadow-Path"><a href="#设定Shadow-Path" class="headerlink" title="设定Shadow Path"></a>设定Shadow Path</h2><blockquote><p>如何在一个View或者一个layer上加一个shadow呢，QuartzCore框架是很多开发者的选择：</p></blockquote><pre><code>UIView *view = [[UIView alloc] init];  view.layer.shadowOffset = CGSizeMake(-1.0f, 1.0f);  view.layer.shadowRadius = 5.0f;  view.layer.shadowOpacity = 0.6;</code></pre><blockquote><p>看起来很简单，对吧。可是，坏消息是使用这个方法也有它的问题… Core Animation不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。</p></blockquote><blockquote><p>使用shadowPath的话就避免了这个问题：</p></blockquote><blockquote><p>view.layer.shadowPath = [[UIBezierPath bezierPathWithRect:view.bounds] CGPath];<br>使用shadow path的话iOS就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算path的话可能在某些View中比较困难，且每当view的frame变化的时候你都需要去update shadow path.</p></blockquote><blockquote><p>我更喜欢用CALayer自己画一个阴影出来，这样可以设置阴影光栅化，节省大量CPU的运算，坏处就是比较消耗内存。因为如果给view的&gt;layer设置光栅化的话整个View都会变得模糊。</p></blockquote><h2 id="优化Table-View"><a href="#优化Table-View" class="headerlink" title="优化Table View"></a>优化Table View</h2><blockquote><p>Table view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。</p></blockquote><blockquote><p>为了保证table view平滑滚动，确保你采取了以下的措施:</p></blockquote><blockquote><p>正确使用reuseIdentifier来重用cells<br>    尽量使所有的view opaque，包括cell自身<br>    避免渐变，图片缩放，后台选人<br>    缓存行高<br>    如果cell内现实的内容来自web，使用异步加载，缓存请求结果<br>    使用shadowPath来画阴影<br>    减少subviews的数量<br>    尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果<br>    使用正确的数据结构来存储数据<br>    使用rowHeight, sectionFooterHeight和 sectionHeaderHeight来设定固定的高，不要请求delegate</p></blockquote><h2 id="选择正确的数据存储选项"><a href="#选择正确的数据存储选项" class="headerlink" title="选择正确的数据存储选项"></a>选择正确的数据存储选项</h2><pre><code>当存储大块数据时你会怎么做？你有很多选择，比如：使用NSUerDefaults使用XML, JSON, 或者 plist使用NSCoding存档使用类似SQLite的本地SQL数据库使用 Core DataNSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了XML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。如果你使用SQLite，你可以用FMDB(https://GitHub.com/ccgus/fmdb)这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C API了。</code></pre><h2 id="使用Autorelease-Pool"><a href="#使用Autorelease-Pool" class="headerlink" title="使用Autorelease Pool"></a>使用Autorelease Pool</h2><blockquote><p>NSAutoreleasePool负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。</p></blockquote><blockquote><p>假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。好消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为：</p></blockquote><pre><code>NSArray *urls = &lt;# An array of file URLs #&gt;;     for(NSURL *url in urls) {      @autoreleasepool {         NSError *error;         NSString *fileContents = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];         /* Process the string, creating and autoreleasing more objects. */       }     }</code></pre><blockquote><p>这段代码在每次遍历后释放所有autorelease对象</p></blockquote><h2 id="选择是否缓存图片"><a href="#选择是否缓存图片" class="headerlink" title="选择是否缓存图片"></a>选择是否缓存图片</h2><blockquote><p>常见的从bundle中加载图片的方式有两种，一个是用imageNamed，二是用imageWithContentsOfFile，第一种比较常见一点。</p></blockquote><blockquote><p>既然有两种类似的方法来实现相同的目的，那么他们之间的差别是什么呢？</p></blockquote><blockquote><p>imageNamed的优点是当加载时会缓存图片。imageNamed的文档中这么说:这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。</p></blockquote><blockquote><p>相反的，imageWithContentsOfFile仅加载图片。</p><p>下面的代码说明了这两种方法的用法:</p></blockquote><pre><code>UIImage *img = [UIImage imageNamed:@&quot;myImage&quot;];// caching// orUIImage *img = [UIImage imageWithContentsOfFile:@&quot;myImage&quot;];// no caching</code></pre><blockquote><p>那么我们应该如何选择呢？</p></blockquote><blockquote><p>如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用imageWithContentsOfFile足矣，这样不会浪费内存来缓存它。</p></blockquote><blockquote><p>然而，在图片反复重用的情况下imageNamed是一个好得多的选择。</p></blockquote><h2 id="避免日期格式转换"><a href="#避免日期格式转换" class="headerlink" title="避免日期格式转换"></a>避免日期格式转换</h2><blockquote><p>如果你要用NSDateFormatter来处理很多日期格式，应该小心以待。就像先前提到的，任何时候重用NSDateFormatters都是一个好的实践。</p></blockquote><blockquote><p>然而，如果你需要更多速度，那么直接用C是一个好的方案。Sam Soffes有一个不错的帖子(<a href="http://soff.es/how-to-drastically-improve-your-app-with-an-afternoon-and-instruments)里面有一些可以用来解析ISO-8601日期字符串的代码，简单重写一下就可以拿来用了。" target="_blank" rel="noopener">http://soff.es/how-to-drastically-improve-your-app-with-an-afternoon-and-instruments)里面有一些可以用来解析ISO-8601日期字符串的代码，简单重写一下就可以拿来用了。</a></p></blockquote><blockquote><p>嗯，直接用C来搞，看起来不错了，但是你相信吗，我们还有更好的方案！</p></blockquote><blockquote><p>如果你可以控制你所处理的日期格式，尽量选择Unix时间戳。你可以方便地从时间戳转换到NSDate:</p></blockquote><pre><code>- (NSDate*)dateFromUnixTimestamp:(NSTimeInterval)timestamp {    return[NSDate dateWithTimeIntervalSince1970:timestamp];}</code></pre><blockquote><p>这样会比用C来解析日期字符串还快！需要注意的是，许多web API会以微秒的形式返回时间戳，因为这种格式在javascript中更方便使用。记住用dateFromUnixTimestamp之前除以1000就好了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;用ARC管理内存&quot;&gt;&lt;a href=&quot;#用ARC管理内存&quot; class=&quot;headerlink&quot; title=&quot;用ARC管理内存&quot;&gt;&lt;/a&gt;用ARC管理内存&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codeceo.com/article/optimize-ios-program-performance.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转自 http://www.codeceo.com/article/optimize-ios-program-performance.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="转载" scheme="https://liangdahong.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>转 - 面试中的 10 大排序算法总结</title>
    <link href="https://liangdahong.com/2018/05/22/%E8%BD%AC%E8%BD%BD/%E8%BD%AC-%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84-10-%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://liangdahong.com/2018/05/22/转载/转-面试中的-10-大排序算法总结/</id>
    <published>2018-05-22T15:42:55.000Z</published>
    <updated>2018-08-06T09:32:03.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://www.codeceo.com/article/10-sort-algorithm-interview.html#0-tsina-1-10490-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="noopener">本文转载自码农网</a></li><li><a href="https://github.com/francistao/LearningNotes" target="_blank" rel="noopener">https://github.com/francistao/LearningNotes</a></li></ul><a id="more"></a><p></p><p>查找和排序算法是算法的入门知识，其经典思想可以用于很多算法当中。因为其实现代码较短，应用较常见。所以在面试中经常会问到排序算法及其相关的问题。但万变不离其宗，只要熟悉了思想，灵活运用也不是难事。一般在面试中最常考的是快速排序和归并排序，并且经常有面试官要求现场写出这两种排序的代码。对这两种排序的代码一定要信手拈来才行。还有插入排序、冒泡排序、堆排序、基数排序、桶排序等。面试官对于这些排序可能会要求比较各自的优劣、各种算法的思想及其使用场景。还有要会分析算法的时间和空间复杂度。通常查找和排序算法的考察是面试的开始，如果这些问题回答不好，估计面试官都没有继续面试下去的兴趣都没了。所以想开个好头就要把常见的排序算法思想及其特点要熟练掌握，有必要时要熟练写出代码。</p><p></p><p></p><p>接下来我们就分析一下常见的排序算法及其使用场景。限于篇幅，某些算法的详细演示和图示请自行寻找详细的参考。</p><p></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p></p><p>冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。</p><p></p><p></p><p>实现代码：</p><p></p><p><div></div></p><p><pre>/*<em> </em>@Description:&lt;p&gt;冒泡排序算法实现&lt;/p&gt;<br> <em>@author 王旭 </em>@time 2016-3-3 下午8:54:27<br> */<br>public class BubbleSort {</pre></p><pre><code>public static void bubbleSort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    for(int i=0; i&amp;lt;arr.length-1; i++) {        for(int j=arr.length-1; j&amp;gt;i; j--) {            if(arr[j] &amp;lt; arr[j-1]) {                swap(arr, j-1, j);            }        }    }}public static void swap(int[] arr, int i, int j) {    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}</code></pre><p>}<br></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p></p><p>选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2)</p><p></p><p></p><p>实现代码：</p><p></p><p><div></div></p><p><pre>/*<em> </em>@Description:&lt;p&gt;简单选择排序算法的实现&lt;/p&gt;<br> <em>@author 王旭 </em>@time 2016-3-3 下午9:13:35<br> */<br>public class SelectSort {</pre></p><pre><code>public static void selectSort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    int minIndex = 0;    for(int i=0; i&amp;lt;arr.length-1; i++) { //只需要比较n-1次        minIndex = i;        for(int j=i+1; j&amp;lt;arr.length; j++) { //从i+1开始比较，因为minIndex默认为i了，i就没必要比了。            if(arr[j] &amp;lt; arr[minIndex]) {                minIndex = j;            }        }        if(minIndex != i) { //如果minIndex不为i，说明找到了更小的值，交换之。            swap(arr, i, minIndex);        }    }}public static void swap(int[] arr, int i, int j) {    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}</code></pre><p>}<br></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p></p><p>插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是O(n^2)。</p><p></p><p></p><p>实现代码：</p><p></p><p><div></div></p><p><pre>/*<em> </em>@Description:&lt;p&gt;简单插入排序算法实现&lt;/p&gt;<br> <em>@author 王旭 </em>@time 2016-3-3 下午9:38:55<br> */<br>public class InsertSort {</pre></p><pre><code>public static void insertSort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    for(int i=1; i&amp;lt;arr.length; i++) { //假设第一个数位置时正确的；要往后移，必须要假设第一个。        int j = i;        int target = arr[i]; //待插入的        //后移        while(j &amp;gt; 0 &amp;amp;&amp;amp; target &amp;lt; arr[j-1]) {            arr[j] = arr[j-1];            j --;        }        //插入         arr[j] = target;    }}</code></pre><p>}<br></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p></p><p>快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。冒泡排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。</p><p></p><p></p><p>举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。</p><p></p><p></p><p>5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。</p><p></p><p></p><p>5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。</p><p></p><p></p><p>5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。</p><p></p><p></p><p>4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。</p><p></p><p></p><p>上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。</p><p></p><p></p><p>快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。</p><p></p><p></p><p>实现代码：</p><p></p><p><div></div></p><p><pre>/*<em> </em>@Description:&lt;p&gt;实现快速排序算法&lt;/p&gt;<br> <em>@author 王旭 </em>@time 2016-3-3 下午5:07:29<br> */<br>public class QuickSort {<br>    //一次划分<br>    public static int partition(int[] arr, int left, int right) {<br>        int pivotKey = arr[left];<br>        int pivotPointer = left;</pre></p><pre><code>    while(left &amp;lt; right) {        while(left &amp;lt; right &amp;amp;&amp;amp; arr[right] &amp;gt;= pivotKey)            right --;        while(left &amp;lt; right &amp;amp;&amp;amp; arr[left] &amp;lt;= pivotKey)            left ++;        swap(arr, left, right); //把大的交换到右边，把小的交换到左边。    }    swap(arr, pivotPointer, left); //最后把pivot交换到中间    return left;}public static void quickSort(int[] arr, int left, int right) {    if(left &amp;gt;= right)        return ;    int pivotPos = partition(arr, left, right);    quickSort(arr, left, pivotPos-1);    quickSort(arr, pivotPos+1, right);}public static void sort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    quickSort(arr, 0, arr.length-1);}public static void swap(int[] arr, int left, int right) {    int temp = arr[left];    arr[left] = arr[right];    arr[right] = temp;}</code></pre><p>}<br></p><p></p><p>其实上面的代码还可以再优化，上面代码中基准数已经在pivotKey中保存了，所以不需要每次交换都设置一个temp变量，在交换左右指针的时候只需要先后覆盖就可以了。这样既能减少空间的使用还能降低赋值运算的次数。优化代码如下：</p><p></p><p><div></div></p><p><pre>/*<em> </em>@Description:&lt;p&gt;实现快速排序算法&lt;/p&gt;<br> <em>@author 王旭 </em>@time 2016-3-3 下午5:07:29<br> */<br>public class QuickSort {</pre></p><pre><code>/** * 划分 * @param arr * @param left * @param right * @return */public static int partition(int[] arr, int left, int right) {    int pivotKey = arr[left];    while(left &amp;lt; right) {        while(left &amp;lt; right &amp;amp;&amp;amp; arr[right] &amp;gt;= pivotKey)            right --;        arr[left] = arr[right]; //把小的移动到左边        while(left &amp;lt; right &amp;amp;&amp;amp; arr[left] &amp;lt;= pivotKey)            left ++;        arr[right] = arr[left]; //把大的移动到右边    }    arr[left] = pivotKey; //最后把pivot赋值到中间    return left;}/** * 递归划分子序列 * @param arr * @param left * @param right */public static void quickSort(int[] arr, int left, int right) {    if(left &amp;gt;= right)        return ;    int pivotPos = partition(arr, left, right);    quickSort(arr, left, pivotPos-1);    quickSort(arr, pivotPos+1, right);}public static void sort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    quickSort(arr, 0, arr.length-1);}</code></pre><p>}<br></p><p></p><p>总结快速排序的思想：冒泡+二分+递归分治，慢慢体会。。。</p><p></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p></p><p>堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。</p><p></p><p></p><p>首先，实现堆排序需要解决两个问题：</p><p></p><p></p><p>1. 如何由一个无序序列键成一个堆？</p><p></p><p></p><p>2. 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</p><p></p><p></p><p>第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。</p><p></p><p></p><p>第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。</p><p></p><p></p><p>从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子：</p><p></p><p></p><p>49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下：</p><p></p><p></p><p><img src="http://static.codeceo.com/images/2016/03/2614bce119263edcf9d18b6365b39197.png" alt=""></p><p></p><p></p><p><img src="http://static.codeceo.com/images/2016/03/ad373a589182dd1b7e443915c8775fcd.png" alt=""></p><p></p><p></p><p>实现代码：</p><p></p><p><div></div></p><p><pre>/*<em> </em>@Description:&lt;p&gt;堆排序算法的实现，以大顶堆为例。&lt;/p&gt;<br> <em>@author 王旭 </em>@time 2016-3-4 上午9:26:02<br> */<br>public class HeapSort {</pre></p><pre><code>/** * 堆筛选，除了start之外，start~end均满足大顶堆的定义。 * 调整之后start~end称为一个大顶堆。 * @param arr 待调整数组 * @param start 起始指针 * @param end 结束指针 */public static void heapAdjust(int[] arr, int start, int end) {    int temp = arr[start];    for(int i=2*start+1; i&amp;lt;=end; i*=2) {        //左右孩子的节点分别为2*i+1,2*i+2        //选择出左右孩子较小的下标        if(i &amp;lt; end &amp;amp;&amp;amp; arr[i] &amp;lt; arr[i+1]) {            i ++;         }        if(temp &amp;gt;= arr[i]) {            break; //已经为大顶堆，=保持稳定性。        }        arr[start] = arr[i]; //将子节点上移        start = i; //下一轮筛选    }    arr[start] = temp; //插入正确的位置}public static void heapSort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    //建立大顶堆    for(int i=arr.length/2; i&amp;gt;=0; i--) {        heapAdjust(arr, i, arr.length-1);    }    for(int i=arr.length-1; i&amp;gt;=0; i--) {        swap(arr, 0, i);        heapAdjust(arr, 0, i-1);    }}public static void swap(int[] arr, int i, int j) {    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}</code></pre><p>}<br></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p></p><p>希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。</p><p></p><p></p><p>举个栗子：</p><p></p><p></p><p><img src="http://static.codeceo.com/images/2016/03/aef03b0d2339be34627bcd81a3809e62.png" alt=""></p><p></p><p></p><p>从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。</p><p></p><p></p><p>希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到O(n^1.3)。</p><p></p><p></p><p>实现代码：</p><p></p><p><div></div></p><p><pre>/*<em> </em>@Description:&lt;p&gt;希尔排序算法实现&lt;/p&gt;<br> <em>@author 王旭 </em>@time 2016-3-3 下午10:53:55<br> */<br>public class ShellSort {</pre></p><pre><code>/** * 希尔排序的一趟插入 * @param arr 待排数组 * @param d 增量 */public static void shellInsert(int[] arr, int d) {    for(int i=d; i&amp;lt;arr.length; i++) {        int j = i - d;        int temp = arr[i];    //记录要插入的数据          while (j&amp;gt;=0 &amp;amp;&amp;amp; arr[j]&amp;gt;temp) {  //从后向前，找到比其小的数的位置               arr[j+d] = arr[j];    //向后挪动              j -= d;          }          if (j != i - d)    //存在比其小的数             arr[j+d] = temp;    }}public static void shellSort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    int d = arr.length / 2;    while(d &amp;gt;= 1) {        shellInsert(arr, d);        d /= 2;    }}</code></pre><p>}<br></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p></p><p>归并排序是另一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易。其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。</p><p></p><p></p><p>举个栗子：</p><p></p><p></p><p><img src="http://static.codeceo.com/images/2016/03/df8478362d9b42913e022eff94d43eb4.png" alt=""></p><p></p><p></p><p>实现代码：</p><p></p><p><div></div></p><p><pre>/*<em> </em>@Description:&lt;p&gt;归并排序算法的实现&lt;/p&gt;<br> <em>@author 王旭 </em>@time 2016-3-4 上午8:14:20<br> */<br>public class MergeSort {</pre></p><pre><code>public static void mergeSort(int[] arr) {    mSort(arr, 0, arr.length-1);}/** * 递归分治 * @param arr 待排数组 * @param left 左指针 * @param right 右指针 */public static void mSort(int[] arr, int left, int right) {    if(left &amp;gt;= right)        return ;    int mid = (left + right) / 2;    mSort(arr, left, mid); //递归排序左边    mSort(arr, mid+1, right); //递归排序右边    merge(arr, left, mid, right); //合并}/** * 合并两个有序数组 * @param arr 待合并数组 * @param left 左指针 * @param mid 中间指针 * @param right 右指针 */public static void merge(int[] arr, int left, int mid, int right) {    //[left, mid] [mid+1, right]    int[] temp = new int[right - left + 1]; //中间数组    int i = left;    int j = mid + 1;    int k = 0;    while(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) {        if(arr[i] &amp;lt;= arr[j]) {            temp[k++] = arr[i++];        }        else {            temp[k++] = arr[j++];        }    }    while(i &amp;lt;= mid) {        temp[k++] = arr[i++];    }    while(j &amp;lt;= right) {        temp[k++] = arr[j++];    }    for(int p=0; p&amp;lt;temp.length; p++) {        arr[left + p] = temp[p];    }}</code></pre><p>}<br></p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p></p><p>如果在面试中有面试官要求你写一个O(n)时间复杂度的排序算法，你千万不要立刻说：这不可能！虽然前面基于比较的排序的下限是O(nlogn)。但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满足一定的范围的整数，而且计数排序需要比较多的辅助空间。其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。</p><p></p><p></p><p>实现代码：</p><p></p><p><div></div></p><p><pre>/*<em> </em>@Description:&lt;p&gt;计数排序算法实现&lt;/p&gt;<br> <em>@author 王旭 </em>@time 2016-3-4 下午4:52:02<br> */<br>public class CountSort {</pre></p><pre><code>public static void countSort(int[] arr) {    if(arr == null || arr.length == 0)        return ;    int max = max(arr);    int[] count = new int[max+1];    Arrays.fill(count, 0);    for(int i=0; i&amp;lt;arr.length; i++) {        count[arr[i]] ++;    }    int k = 0;    for(int i=0; i&amp;lt;=max; i++) {        for(int j=0; j&amp;lt;count[i]; j++) {            arr[k++] = i;        }    }}public static int max(int[] arr) {    int max = Integer.MIN_VALUE;    for(int ele : arr) {        if(ele &amp;gt; max)            max = ele;    }    return max;}</code></pre><p>}<br></p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p></p><p>桶排序算是计数排序的一种改进和推广，但是网上有许多资料把计数排序和桶排序混为一谈。其实桶排序要比计数排序复杂许多。</p><p></p><p></p><p>对桶排序的分析和解释借鉴这位兄弟的文章（有改动）：<a href="http://hxraid.iteye.com/blog/647759" target="_blank" rel="noopener">http://hxraid.iteye.com/blog/647759</a></p><p></p><p></p><p>桶排序的基本思想：</p><p></p><p></p><p>假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]&#8230;.B[M]中的全部内容即是一个有序序列。bindex=f(key)   其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1&lt;k2，那么f(k1)&lt;=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系。</p><p></p><p></p><p>举个栗子：</p><p></p><p></p><p><img src="http://static.codeceo.com/images/2016/03/47bcf435950f64c848ce43d5ae5142aa.gif" alt=""></p><p></p><p></p><p>假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序后得到如图所示。只要顺序输出每个B[i]中的数据就可以得到有序序列了。</p><p></p><p></p><p>桶排序分析：</p><p></p><p></p><p>桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。</p><p></p><p></p><p>对N个关键字进行桶排序的时间复杂度分为两个部分：</p><p></p><p></p><p>(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。</p><p></p><p></p><p>(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为  ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。</p><p></p><p></p><p>很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：</p><p></p><p></p><p>(1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。</p><p></p><p></p><p>(2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</p><p></p><p></p><p>对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：</p><p></p><p></p><p>O(N)+O(M<em>(N/M)</em>log(N/M))=O(N+N<em>(logN-logM))=O(N+N</em>logN-N*logM)</p><p></p><p></p><p>当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。</p><p></p><p></p><p><strong>总结：</strong> 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。</p><p></p><p></p><p>实现代码：</p><p></p><p><div></div></p><p><pre>/*<em> </em>@Description:&lt;p&gt;桶排序算法实现&lt;/p&gt;<br> <em>@author 王旭 </em>@time 2016-3-4 下午7:39:31<br> */<br>public class BucketSort {</pre></p><pre><code>public static void bucketSort(int[] arr) {    if(arr == null &amp;amp;&amp;amp; arr.length == 0)        return ;    int bucketNums = 10; //这里默认为10，规定待排数[0,100)    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buckets = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;(); //桶的索引    for(int i=0; i&amp;lt;10; i++) {        buckets.add(new LinkedList&amp;lt;Integer&amp;gt;()); //用链表比较合适    }    //划分桶    for(int i=0; i&amp;lt;arr.length; i++) {        buckets.get(f(arr[i])).add(arr[i]);    }    //对每个桶进行排序    for(int i=0; i&amp;lt;buckets.size(); i++) {        if(!buckets.get(i).isEmpty()) {            Collections.sort(buckets.get(i)); //对每个桶进行快排        }    }    //还原排好序的数组    int k = 0;    for(List&amp;lt;Integer&amp;gt; bucket : buckets) {        for(int ele : bucket) {            arr[k++] = ele;        }    }}/** * 映射函数 * @param x * @return */public static int f(int x) {    return x / 10;}</code></pre><p>}<br></p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p></p><p>基数排序又是一种和前面排序方式不同的排序方式，基数排序不需要进行记录关键字之间的比较。基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。所谓的多关键字排序就是有多个优先级不同的关键字。比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面。。。如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字，如果要进行升序排序，那么个位、十位、百位优先级一次增加。基数排序是通过多次的收分配和收集来实现的，关键字优先级低的先进行分配和收集。</p><p></p><p></p><p>举个栗子：</p><p></p><p></p><p><img src="http://static.codeceo.com/images/2016/03/cb56ff40b1ade7e57d5aa9840fc1eba3.png" alt=""></p><p></p><p></p><p><img src="http://static.codeceo.com/images/2016/03/75d38cce23336e133dd8eac33eabf5ad.png" alt=""></p><p></p><p></p><p>实现代码：</p><p></p><p><div></div></p><p><pre>/*<em> </em>@Description:&lt;p&gt;基数排序算法实现&lt;/p&gt;<br> <em>@author 王旭 </em>@time 2016-3-4 下午8:29:52<br> */<br>public class RadixSort {</pre></p><pre><code>public static void radixSort(int[] arr) {    if(arr == null &amp;amp;&amp;amp; arr.length == 0)        return ;    int maxBit = getMaxBit(arr);    for(int i=1; i&amp;lt;=maxBit; i++) {        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buf = distribute(arr, i); //分配        collecte(arr, buf); //收集    }}/** * 分配 * @param arr 待分配数组 * @param iBit 要分配第几位 * @return */public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; distribute(int[] arr, int iBit) {    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buf = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();    for(int j=0; j&amp;lt;10; j++) {        buf.add(new LinkedList&amp;lt;Integer&amp;gt;());    }    for(int i=0; i&amp;lt;arr.length; i++) {        buf.get(getNBit(arr[i], iBit)).add(arr[i]);    }    return buf;}/** * 收集 * @param arr 把分配的数据收集到arr中 * @param buf  */public static void collecte(int[] arr, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buf) {    int k = 0;    for(List&amp;lt;Integer&amp;gt; bucket : buf) {        for(int ele : bucket) {            arr[k++] = ele;        }    }}/** * 获取最大位数 * @param x * @return */public static int getMaxBit(int[] arr) {    int max = Integer.MIN_VALUE;    for(int ele : arr) {        int len = (ele+&quot;&quot;).length();        if(len &amp;gt; max)            max = len;    }    return max;}/** * 获取x的第n位，如果没有则为0. * @param x * @param n * @return */public static int getNBit(int x, int n) {    String sx = x + &quot;&quot;;    if(sx.length() &amp;lt; n)        return 0;    else        return sx.charAt(sx.length()-n) - &apos;0&apos;;}</code></pre><p>}<br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p></p><p>在前面的介绍和分析中我们提到了冒泡排序、选择排序、插入排序三种简单的排序及其变种快速排序、堆排序、希尔排序三种比较高效的排序。后面我们又分析了基于分治递归思想的归并排序还有计数排序、桶排序、基数排序三种线性排序。我们可以知道排序算法要么简单有效，要么是利用简单排序的特点加以改进，要么是以空间换取时间在特定情况下的高效排序。但是这些排序方法都不是固定不变的，需要结合具体的需求和场景来选择甚至组合使用。才能达到高效稳定的目的。没有最好的排序，只有最适合的排序。</p><p></p><p></p><p>下面就总结一下排序算法的各自的使用场景和适用场合。</p><p></p><p></p><p><img src="http://static.codeceo.com/images/2016/03/2f0f5c6b5c7b007b00f0d33427a70db0.png" alt=""></p><p></p><p></p><p>1. 从平均时间来看，快速排序是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后者相比较的结果是，在n较大时归并排序使用时间较少，但使用辅助空间较多。</p><p></p><p></p><p>2. 上面说的简单排序包括除希尔排序之外的所有冒泡排序、插入排序、简单选择排序。其中直接插入排序最简单，但序列基本有序或者n较小时，直接插入排序是好的方法，因此常将它和其他的排序方法，如快速排序、归并排序等结合在一起使用。</p><p></p><p></p><p>3. 基数排序的时间复杂度也可以写成O(d*n)。因此它最使用于n值很大而关键字较小的的序列。若关键字也很大，而序列中大多数记录的最高关键字均不同，则亦可先按最高关键字不同，将序列分成若干小的子序列，而后进行直接插入排序。</p><p></p><p></p><p>4. 从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n^2)的简单排序也是稳定的。但是快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择。</p><p></p><p></p><p>5. 上面的算法实现大多数是使用线性存储结构，像插入排序这种算法用链表实现更好，省去了移动元素的时间。具体的存储结构在具体的实现版本中也是不同的。</p><p></p><p></p><p>附：基于比较排序算法时间下限为O(nlogn)的证明：</p><p></p><p></p><p>基于比较排序下限的证明是通过决策树证明的，决策树的高度Ω（nlgn），这样就得出了比较排序的下限。</p><p></p><p></p><p><img src="http://static.codeceo.com/images/2016/03/b4d51a192d469b833a46695c0a7668f6.jpg" alt=""></p><p></p><p></p><p>首先要引入决策树。 首先决策树是一颗二叉树，每个节点表示元素之间一组可能的排序，它予以京进行的比较相一致，比较的结果是树的边。 先来说明一些二叉树的性质，令T是深度为d的二叉树，则T最多有2^片树叶。 具有L片树叶的二叉树的深度至少是logL。 所以，对n个元素排序的决策树必然有n!片树叶（因为n个数有n!种不同的大小关系），所以决策树的深度至少是log(n!)，即至少需要log(n!)次比较。 而 log(n!)=logn+log(n-1)+log(n-2)+&#8230;+log2+log1 &gt;=logn+log(n-1)+log(n-2)+&#8230;+log(n/2) &gt;=(n/2)log(n/2) &gt;=(n/2)logn-n/2 =O(nlogn) 所以只用到比较的排序算法最低时间复杂度是O(nlogn)。</p><p></p><p></p><p><strong>参考资料：</strong></p><p></p><p><ul></ul></p><p><li>《数据结构》 严蔚敏 吴伟民 编著</li></p><p><li>桶排序分析：<a href="http://hxraid.iteye.com/blog/647759" target="_blank" rel="noopener">http://hxraid.iteye.com/blog/647759</a></li></p><p><li>部分排序算法分析与介绍：<a href="http://www.cnblogs.com/weixliu/archive/2012/12/23/2829671.html" target="_blank" rel="noopener">http://www.cnblogs.com/weixliu/archive/2012/12/23/2829671.html</a></li><br></p><script type="text/javascript">var strBatchView = 37731</script><p><a id="soft-link" name="soft-link"></a></p><p><div style="width:336px;height:280px;margin:40px auto"></div></p><p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br><!-- codeceo-bottom-big --><br><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-3171310320403916" data-ad-slot="5138981789"></ins></p><script></script>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codeceo.com/article/10-sort-algorithm-interview.html#0-tsina-1-10490-397232819ff9a47a7b7e80a40613cfe1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文转载自码农网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/francistao/LearningNotes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/francistao/LearningNotes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="转载" scheme="https://liangdahong.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Web 前端学习笔记之一</title>
    <link href="https://liangdahong.com/2018/04/13/2018/Web-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/"/>
    <id>https://liangdahong.com/2018/04/13/2018/Web-前端学习笔记之一/</id>
    <published>2018-04-13T07:08:13.000Z</published>
    <updated>2018-07-10T02:26:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li>HTML 结构</li></ul><ul><li>CSS 内嵌写法 / 外链写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">...  </span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;1.css&quot;&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>JavaScript 内嵌写法 / 外链写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>JavaScript 的几种调试方式</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;ssssss&apos;); // alert 确定按钮</span><br><span class="line">confirm(&apos;s&apos;); // alert + 确定 和 取消按钮</span><br><span class="line">console.log(&apos;2&apos;);  // 控制台输出</span><br><span class="line">prompt(&apos;sss&apos;);    // 弹出一个用户输入框 搜集消息</span><br><span class="line">document.write(&apos;ssss&apos;) ; // 在页面输入内容</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSS&quot;&gt;&lt;a href=&quot;#CSS&quot; class=&quot;headerlink&quot; title=&quot;CSS&quot;&gt;&lt;/a&gt;CSS&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HTML 结构&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;CSS 内嵌写法 / 外链写法&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;1.css&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Web" scheme="https://liangdahong.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>微信小程序</title>
    <link href="https://liangdahong.com/2018/03/26/2018/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>https://liangdahong.com/2018/03/26/2018/微信小程序/</id>
    <published>2018-03-26T09:37:50.000Z</published>
    <updated>2018-08-07T01:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><a id="more"></a><pre><code>WXS 语言目前共有以下几种数据类型：number ： 数值string ：字符串boolean：布尔值object：对象function：函数array : 数组date：日期regexp：正则</code></pre><ul><li><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxs/06datatype.html" target="_blank" rel="noopener">小程序官方文档</a></li></ul><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个数组</span><br><span class="line">var arr = []</span><br><span class="line"></span><br><span class="line">// 添加一个对象,同时返回添加后的数组长度</span><br><span class="line">arr.push(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">// 删除最后一个对象,同时返回这个数组</span><br><span class="line">arr.pop()</span><br><span class="line"></span><br><span class="line">// 从sidx位置开始删除len个对象</span><br><span class="line">arr.splice(sidx, len)</span><br></pre></td></tr></table></figure><p><code>JavaScript中对数组的一些操作函数，可参考</code></p><p><img src="http://files.jb51.net/file_images/article/201701/2017010515261024.jpg"></p><h3 id="String-和-Number-相互转换"><a href="#String-和-Number-相互转换" class="headerlink" title="String 和 Number 相互转换"></a>String 和 Number 相互转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 会自动忽略掉末尾的0 比如 【  1.00.toString() = '1'   】 【  parseFloat('1.00') = 1 】</span></span><br><span class="line">var n = <span class="number">10</span></span><br><span class="line">String(<span class="number">1</span>)</span><br><span class="line">n.toString()</span><br><span class="line">console.<span class="built_in">log</span>(parseInt(<span class="string">"1.001"</span>));</span><br><span class="line">console.log(parseFloat('1.00'));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 价格转换</span></span><br><span class="line">var price = <span class="number">100.99</span>; <span class="comment">// 元为单位</span></span><br><span class="line">price.toFixed(price);  <span class="comment">// '100.99'</span></span><br><span class="line">(<span class="number">100.00</span>).toFixed();  <span class="comment">// '100.00'</span></span><br><span class="line"></span><br><span class="line">var price = <span class="number">10009</span>; <span class="comment">// 分为单位</span></span><br><span class="line">(<span class="number">10009</span>/<span class="number">100.0</span>).toFixed(price);  <span class="comment">// '100.99'</span></span><br><span class="line">(<span class="number">10000</span>/<span class="number">100.0</span>).toFixed(<span class="number">100.00</span>);  <span class="comment">// '100.00'</span></span><br></pre></td></tr></table></figure><h2 id="JS文件中的各种写法"><a href="#JS文件中的各种写法" class="headerlink" title="JS文件中的各种写法"></a>JS文件中的各种写法</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 使用 module.exports 输出对象</span><br><span class="line">module.exports = &#123;formatTime: formatTime&#125;</span><br><span class="line"></span><br><span class="line">// 引用</span><br><span class="line">const obj = require(&apos;./utils/util&apos;)  // 相对路径  . 表示当前路径  .. 表示当前路径的上一层路径</span><br><span class="line">const obj = require(&apos;/utils/util&apos;)   // 绝对路径</span><br><span class="line">const obj = require(&apos;../utils/util&apos;) // 相对路径</span><br><span class="line"></span><br><span class="line">// 定义一个变量</span><br><span class="line">var num1 = 10;</span><br><span class="line"></span><br><span class="line">// 定义一个常量</span><br><span class="line">const num2 = 10;</span><br><span class="line"></span><br><span class="line">// 定义一个函数</span><br><span class="line">var f2 = function(res) &#123;&#125;</span><br><span class="line">// 定义一个函数</span><br><span class="line">var f3 = (res) =&gt; &#123;&#125;</span><br><span class="line">// 定义一个函数</span><br><span class="line">var f4 = res =&gt; &#123;&#125;</span><br><span class="line">// 定义一个函数</span><br><span class="line">function get(res) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个对象，在对象中定义函数和在外面基本一样</span><br><span class="line">var http = &#123;</span><br><span class="line">  a: () =&gt; &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  kk: 10,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更简洁的方式</span><br><span class="line">fun(&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  //  module class  Promise  箭头函数 =&gt; </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;微信小程序&quot;&gt;&lt;a href=&quot;#微信小程序&quot; class=&quot;headerlink&quot; title=&quot;微信小程序&quot;&gt;&lt;/a&gt;微信小程序&lt;/h1&gt;&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="https://liangdahong.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Nots</title>
    <link href="https://liangdahong.com/2018/02/26/2018/Nots/"/>
    <id>https://liangdahong.com/2018/02/26/2018/Nots/</id>
    <published>2018-02-26T07:11:51.000Z</published>
    <updated>2018-08-07T09:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h2><a id="more"></a><blockquote><ul><li>HTTP 超文本传输协议（HyperText Transfer Protocol)</li><li>TCP 传输控制协议（Transmission Control Protocol) </li><li>IP 网际协议（Internet Protocol)</li><li>HTML 超文本标记语言（HyperText Markup Language)</li><li>CSS 层叠样式表(Cascading Style Sheets)</li><li>URI 统一资源标识符（Uniform Resource Identifier)</li><li>URL 统一资源定位符（Uniform Resource Locator)</li><li>URN 统一资源名称（Uniform Resource Name)</li></ul></blockquote><pre><code>应用层 HTTP     ↓  表示层     ↓  会话层     ↓传输层 TCP     ↓  网络层 IP     ↓ 数据链路层     ↓  物理层</code></pre><h2 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h2><ul><li><a href="http://www.w3school.com.cn/tags/index.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/index.asp</a></li></ul><hr><ol><li>注释标签</li><li>br 标签 换行标签</li><li>hr 分割线标签</li><li>p  段落标签</li><li>h1…h6 标题标签，一个界面最多一个h1标签，搜索引擎搜索问题</li><li>font 文本标签</li><li>html 标签，root标签，</li><li>body 主体标签，给用户看的内容在这里面，浏览器也需看</li><li>head head标签，只要是给浏览器看的内容</li><li>title 标签标签，网站名称</li><li>strong （文本标签 font 的加粗样式，也可以使用 b ，b只是简单的加粗，但strong有更好的着重意义，推荐使用 strong）</li><li>em （文本标签 font 的斜体样式，也可以使用 i ，i只是简单的斜体，但em有更好的着重意义，推荐使用 em）</li><li>del (删除线标签 也可以使用 s 推荐使用 del)</li><li>ins （下划线标签  也可以使用 u  推荐使用 ins ）</li><li>a （超链接 title 提示文字）</li><li>img （图片标签，可以设置加载失败的占位文字 提醒文字等 height width等，路径使用..表示到上一个文件夹）</li><li>锚点id 在标签中添加锚点，可以在超链接中设置点击超链接到指定的锚点</li><li>特殊符号 和OC中的转义字符一样，需要特殊处理，需注意下</li><li>列表 ul li 表示无序列表，type可以设置前面的图标类型</li><li>列表 ol li 有序列表，可以使用type设置编号类型 start表示从xx开始</li><li>列表 dl 自定义列表 dt标题 dd标签介绍</li><li>embed 音乐标签</li><li>marquee 滚动标签 文字（图片等）跑马灯自动滚动</li><li>abbr 简写标签，在移动到此内容时，自动显示详细内容。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;&lt;/head&gt; 浏览器看的</span><br><span class="line"></span><br><span class="line">&lt;body&gt;&lt;/body&gt; 主体 用户看的内容</span><br><span class="line"></span><br><span class="line">&lt;title&gt;&lt;/title&gt;  网站标题</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;/p&gt;  段落</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;&lt;/strong&gt; 强调加粗黑体,在阅读时会强调着用，b 只是简单的加粗黑体</span><br><span class="line"></span><br><span class="line">&lt;em&gt;&lt;/em&gt;  着重 i也可以，建议使用 em</span><br><span class="line"></span><br><span class="line">&lt;abbr&gt;&lt;/abbr&gt; 简写</span><br><span class="line"></span><br><span class="line">&lt;!----&gt;  注释</span><br><span class="line"></span><br><span class="line">&lt;ins&gt;&lt;/ins&gt;  下划线  u也可以 </span><br><span class="line"></span><br><span class="line">&lt;del&gt;&lt;/del&gt;  删除  s也可以</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;&lt;/h1&gt;  标题</span><br><span class="line">&lt;h6&gt;&lt;/h6&gt; 标题</span><br><span class="line"></span><br><span class="line">&lt;br&gt;换行</span><br><span class="line"></span><br><span class="line">&lt;hr&gt; 分割线</span><br><span class="line"></span><br><span class="line">&lt;address&gt;&lt;/address&gt; 作者信息</span><br><span class="line"></span><br><span class="line">&lt;font size=&quot;30&quot; color=&quot;red&quot;&gt;font &lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&lt;img scr=&quot;sss.png&quot; width=&quot;100&quot; height=&quot;200&quot; alt=&quot;林志玲的图片&quot; title=&quot;我是图片&quot;&gt;</span><br><span class="line">alt 加载失败时是提示文字 加强体验</span><br><span class="line">title 提醒文本 鼠标移动到图片上时</span><br><span class="line">height width 按照比例变化</span><br><span class="line">路径问题  ../ 到上一家目录  目前在当前html文件的目录 开始寻找图片。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;www.xxx.com&quot; title=&quot;提醒文本&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;a target=&quot;_parent&quot;&gt;&lt;/a&gt; </span><br><span class="line">&lt;a target=&quot;_blank&quot;&gt;&lt;/a&gt; 打开新的界面 当前界面不会关闭</span><br><span class="line">&lt;a target=&quot;_self&quot;&gt;&lt;/a&gt; 在当前界面打开，会覆盖调 默认</span><br><span class="line">   &lt;a target=&quot;_top&quot;&gt;&lt;/a&gt;</span><br><span class="line">   在不知道具体到xxx界面时 href=&quot;#&quot; 不需跳转 在当前界面就可以了，以后再补充具体怎么跳转。</span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">   锚点，可以让滚动到界面的指定位置</span><br><span class="line">   定义锚点</span><br><span class="line">   &lt;p id=&quot;top&quot;&gt;&lt;/p&gt;</span><br><span class="line">   超链接点击就到锚点</span><br><span class="line">   &lt;a href=&quot;#top&quot;&gt; 去顶部啊啊啊啊 &lt;/a&gt;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">特殊符号(转移字符需特殊处理下才可以 可以自行查看和补充)</span><br><span class="line">空格 &amp;nbsp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">列表</span><br><span class="line">无序列表（没有重要区分）</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;001&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;002&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;003&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;004&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;005&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;  </span><br><span class="line">type 表示前面的符号类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有序列表（有重要区分 12345）</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;001&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;002&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;003&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;004&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;005&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">type 1 A i .....</span><br><span class="line">start 从xxx开始</span><br><span class="line"></span><br><span class="line">自定义列表</span><br><span class="line"></span><br><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;dt 小标题&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;dd 解释标题&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br><span class="line"></span><br><span class="line">音乐标签</span><br><span class="line">&lt;embed src=&quot;1.mp3&quot; hiden=&quot;true&quot;&gt;&lt;/embed&gt;</span><br><span class="line"></span><br><span class="line">滚动标签 （可查看其他属性）</span><br><span class="line">marquee</span><br></pre></td></tr></table></figure><h2 id="块标签"><a href="#块标签" class="headerlink" title="块标签"></a>块标签</h2><ul><li>div p h1-h6 ul li </li><li>不设置宽度时默认和父标签的宽度一样，而且会独立站一行。</li><li>块转行 display：inLine</li><li>块转行内块 display：inline-block</li></ul><h2 id="行内标签"><a href="#行内标签" class="headerlink" title="行内标签"></a>行内标签</h2><ul><li>span a strong em del ins </li><li>连续布局，可以一行存放n个标签，自动布局。不可以自定义size，</li><li>行转块 display：block</li><li>行转行内块 display：inline-block</li></ul><h2 id="行内块标签"><a href="#行内块标签" class="headerlink" title="行内块标签"></a>行内块标签</h2><ul><li>img input</li><li>连续布局，可以一行存放n个标签，可以自定义size，</li></ul><h2 id="标签css的继承性"><a href="#标签css的继承性" class="headerlink" title="标签css的继承性"></a>标签css的继承性</h2><ul><li>必须是嵌套关系</li><li>文字颜色 文字大小 文字粗细  整体样式 字体风格 行高 文字属性都可以继承</li><li>h1 可以继承文字大小，但会自动乘一个系数，所以看为不可以继承</li><li>a 链接 不可继承颜色color </li></ul><h2 id="css样式优先级"><a href="#css样式优先级" class="headerlink" title="css样式优先级"></a>css样式优先级</h2><ul><li>默认 &lt; 标签样式 &lt; class &lt; id样式 &lt; 行内样式表  可以使用 !important 强制设置为重要</li><li>继承的的优先级最低</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些名词&quot;&gt;&lt;a href=&quot;#一些名词&quot; class=&quot;headerlink&quot; title=&quot;一些名词&quot;&gt;&lt;/a&gt;一些名词&lt;/h2&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://liangdahong.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS的一点调试技巧</title>
    <link href="https://liangdahong.com/2018/02/12/2018/iOS%E7%9A%84%E4%B8%80%E7%82%B9%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <id>https://liangdahong.com/2018/02/12/2018/iOS的一点调试技巧/</id>
    <published>2018-02-12T07:38:00.000Z</published>
    <updated>2018-08-07T09:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>下面使用GIF简单快速介绍几种断点调试</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/2026898-f8724e8310b74f45.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><ul><li>普通断点</li><li>普通断点编辑为条件断点</li><li>全局断点</li><li>符号断点</li><li>值监控</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://blog.csdn.net/u012729522/article/details/53184711" target="_blank" rel="noopener">http://blog.csdn.net/u012729522/article/details/53184711</a></li><li><a href="https://daiweilai.github.io/2015/04/13/iOS各种调试技巧/" target="_blank" rel="noopener">https://daiweilai.github.io/2015/04/13/iOS各种调试技巧/</a></li><li><a href="https://objccn.io/issue-19-2/" target="_blank" rel="noopener">https://objccn.io/issue-19-2/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;下面使用GIF简单快速介绍几种断点调试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2026898-f8724e8310b74f45.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://liangdahong.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>题目</title>
    <link href="https://liangdahong.com/2018/02/05/2018/%E9%A2%98%E7%9B%AE/"/>
    <id>https://liangdahong.com/2018/02/05/2018/题目/</id>
    <published>2018-02-05T01:49:10.000Z</published>
    <updated>2018-08-07T09:12:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/11/18/12/14/owl-1834152__340.jpg" alt="https://cdn.pixabay.com/photo/2016/11/18/12/14/owl-1834152__340.jpg"></p><a id="more"></a><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="搜狗"><a href="#搜狗" class="headerlink" title="搜狗"></a>搜狗</h2><ul><li>1.iOS应用的文件目录都是什么？缓存文件存在哪个文件里？它的上一层是什么？</li><li>2.SDWebImage图片处理原理？</li><li>3.SDWebImage在iOS9 3dtouch下出现的问题？</li><li>4.NSArray和NSMutableArray在Copy和MutableCopy下的内存是怎样的？</li><li>5.用户下载一个图片，图片很大，需要分成很多份进行下载，使用GCD应该如何实现？使用什么队列？</li><li>6.现有两个人和一张桌子，两个人依次在桌子上放硬币，硬币不能叠放、立着，若一方找不到放的位置则失败。若你在玩这个游戏，设计一个算法必赢。</li><li>7.现有n个物品和一个体积为V的包，每件物品的体积是ci，价格是wi，现在请你往包中放，每件物品只能放一次，怎么放能让包的价格最大。</li></ul><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><ul><li>1.Delegate 、Notification和KVO比较各自的优缺点</li><li>2.在一个UI的正中间实现一个正方形的红色视图有几种方式？</li><li>3.手触碰到屏幕的时候，响应机制是怎样的？第一响应者是谁？追问 UIView和UIResponse的关系是什么？</li><li>4。UIViewController的生命周期是什么？追问 UIViewController 只alloc而没用到的时候，UIViewController 的view是否加载了？如果没有加载那什么时候加载？</li><li>5.直接用UILabel和自己用DrawRect画UILabel，哪个性能好？为什么？哪个占用的内存少？为什么?</li><li>6.AFNetworking是否支持ipv6？</li><li>7.项目采用64位，为什么要用64位？怎么修改成64位？i386是什么？他们有什么关系?</li><li>8.iOS的应用程序有几种状态？追问，退到后台代码是否可以执行？双击home键，代码是否可以执行？</li><li>9.一般使用的图标内存为多大？比如200×300的图片，内存应该占用多少比较合理？</li><li>10.说说你对内存泄漏的看法，追问，block为什么容易引起内存泄漏？</li><li>11.[object copy]是浅拷贝还是深拷贝？为什么是浅拷贝？copy是实现了哪个协议？</li><li>12.Images.xcassets和直接用图片有什么不一样？</li></ul><h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><h3 id="阿里三面"><a href="#阿里三面" class="headerlink" title="阿里三面"></a>阿里三面</h3><ul><li>1.dSYM你是如何分析的？</li><li>2.多线程有哪几种？你更倾向于哪一种？</li><li>3.单例弊端？</li><li>4.如何把异步线程转换成同步任务进行单元测试？</li><li>5.介绍下App启动的完成过程？</li><li>6.比如App启动过慢，你可能想到的因素有哪些？</li><li>7.0x8badf00d表示是什么？</li><li>8.怎么防止反编译？</li><li>9.说说你遇到到的技术难点？</li><li>10.说说你了解的第三方原理或底层知识？</li></ul><h3 id="阿里p6一面"><a href="#阿里p6一面" class="headerlink" title="阿里p6一面"></a>阿里p6一面</h3><ul><li>1.介绍下内存的几大区域？</li><li>2.你是如何组件化解耦的？</li><li>3.runtime如何通过selector找到对应的IMP地址</li><li>4.runloop内部实现逻辑？</li><li>5.你理解的多线程？</li><li>6.GCD执行原理？</li><li>7.怎么防止别人动态在你程序生成代码</li><li>8.YYAsyncLayer如何异步绘制？</li><li>9.优化你是从哪几方面着手？</li></ul><h3 id="淘宝P6"><a href="#淘宝P6" class="headerlink" title="淘宝P6"></a>淘宝P6</h3><ul><li>1.查找字符串算法</li><li>2数组匹配算法</li><li>3.代码文件编译生成过程，编译和链接有什么区别，链接做了什么事情</li><li>4.用C语言实现一个通知流程</li><li>5.A B 线程执行到一半去执行C线程，用OC和C各自怎么实现。</li><li>6.用过GCD什么方法</li><li>7对什么技术比较感兴趣</li><li>8.tableview怎么优化，优化后还是感觉卡怎么办</li><li>9.怎么定位到野指针的地方。如果还没定位到，这个对象被提前释放了，怎么知道该对象在什么地方释放的</li><li>10.ARC的实现原理，什么情况下用MRC比ARC好</li><li>11.懂视频技术吗</li><li>12.16进制的FF + 2后 等于什么  有哪几种情况？</li></ul><h3 id="口碑p6-7"><a href="#口碑p6-7" class="headerlink" title="口碑p6-7"></a>口碑p6-7</h3><ul><li>1.Nsstring栈空间占了多少？</li><li>2.SD最大支持多少个下载数？</li><li>3.yykit如何异步渲染？</li><li>4.runtime动态创建一个类，需要注意什么？</li><li>5.runloop和线程有和关系？</li><li>6.你平时做过什么有技术难点的东西，然后解决难点</li><li>7.你是如何学习iOS，看什么网站，列举几个国外的学习网站？</li><li>8.技术架构如何搭建？</li><li>9.还有一个很长字符串，你用什么算法搜索到abc的位置？</li><li>10.字符串如何预处理？</li><li>11.https和ssl在握手方向有什么区别？</li></ul><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="腾讯二面"><a href="#腾讯二面" class="headerlink" title="腾讯二面"></a>腾讯二面</h3><ul><li>1.编译过程做了哪些事情；</li><li>2.字典大致实现原理；</li><li>3.block和函数指针的理解；</li><li>4.一般开始做一个项目，你的架构是如何思考的？</li><li>5.你了解的UIKit结构？</li></ul><h3 id="腾讯三面"><a href="#腾讯三面" class="headerlink" title="腾讯三面"></a>腾讯三面</h3><ul><li>OC你了解的锁有哪些？在你回答基础上进行二次提问；</li><li>追问一：自旋和互斥对比？</li><li>追问二：使用以上锁需要注意哪些？</li><li>追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！</li><li>内存泄漏可能会出现的几种原因，聊聊你的看法？</li><li>追问一：非OC对象如何处理？</li><li>追问二：地图类内存若泄漏，如何处理？</li><li>追问三：若常用框架出现内存泄漏如何处理？</li><li>容错处理你们一般是怎么做的？</li><li>项目开始容错处理没做？如何防止拦截潜在的崩溃？</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>notification是同步还是异步?和delegate相比有什么区别,效率呢?</li><li>关键字static const的作用</li><li>简述一下CALayer和UIView的关系</li><li>如何让程序进入后台继续相应服务.</li><li>至少写出五种常用的设计模式，说说他们在什么情况下会用到</li><li>简述UITableViewController的DataSource和Delegate的用途.</li><li>AFN、 SDWebImage底层实现？</li><li>分别描述委托(protocol),target,通知(notification)的区别和使用方式.</li><li>类别的作用?继承和类别在实现中有何区别?类别和类扩展的区别.</li><li>UIView和CALayer的区别?</li><li>简述事件传递和响应者链?</li><li>当键盘出现的时候，如何让UITextField自动上移，说说你的做法。</li><li>你在项目中用过哪些数据持久化的方法,并说明为什么用这个.</li><li>说一下你对iOS App安全的理解。</li><li>NSOperation 怎么使用？</li><li>import 跟#include、@class有什么区别？＃import\&lt;> 跟 #import””又什么区别？</li><li>属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用？</li><li>对于语句NSString*obj = [[NSData alloc] init]; ，编译时和运行时obj分别是什么类型？</li><li>谈谈对KVO, 和 KVC的理解?</li><li>谈谈什么是”懒加载”, 应用场景是什么?</li><li>如果使用sqlite, 大批量的插入数据, 需要做哪些优化?</li><li>线程和进程的区别？</li><li>简述UITableView的重用机制？</li><li>self.跟self->什么区别？</li><li>简述@protected ,@private,@public,@package，各有什么含义作用？</li><li>写一个标准宏MIN，这个宏输入两个参数并返回较小的一个？</li><li>面向对象的三大特征，并作简单的介绍</li><li>如何实现APP的本地化?</li><li>控制器之间的传值方式有哪些?</li><li>有没有写过自定义的控件？</li></ol><h2 id="其他2"><a href="#其他2" class="headerlink" title="其他2"></a>其他2</h2><blockquote><p><a href="https://www.jianshu.com/p/79c9a8b9b313" target="_blank" rel="noopener">原链接https://www.jianshu.com/p/79c9a8b9b313</a></p></blockquote><ul><li>1、如何令自己所写的对象具有拷贝功能?</li><li>2、说说你理解weak属性？</li><li>3、题目：Swift mutating关键字的使用？</li><li>4、UIView和CALayer是什么关系?</li><li>5、下面的代码输出什么？</li><li>6、@synthesize 和 @dynamic 分别有什么作用？</li><li>7、动态绑定</li><li>8、Category（类别）、 Extension（扩展）和继承的区别</li><li>9、为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别？</li><li>10、id和NSObject＊的区别</li><li>11、如何令自己所写的对象具有拷贝功能?</li><li>12、使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</li><li>13、用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</li><li>14、UIView和 CALayer是什么关系?</li><li>15、static有什么作用?</li></ul><h3 id="底层："><a href="#底层：" class="headerlink" title="底层："></a>底层：</h3><ul><li>16、main()之前的过程有哪些？</li><li>17、KVO基本原理？</li><li>18、Swift 下的如何使用 KVC?</li><li>19、：Swift有哪些模式匹配？</li><li>20、objc在向一个对象发送消息时，发生了什么？</li><li>21、静态库的原理是什么？你有没有自己写过静态编译库，遇到了哪些问题？</li><li>22、runloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？</li><li>23、不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建</li><li>24、不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</li><li>25、OC完整的消息转发机制+代码实现【暴击】</li><li>26、以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</li><li>27、如何手动触发一个value的KVO</li><li>28、如何对定位和分析项目中影响性能的地方？以及如何进行性能优化？</li><li>29、串行并行，异步同步的区别？</li><li>30、线程是什么？进程是什么？二者有什么区别和联系？</li><li>31、RunLoop是什么？</li><li>32、假设有一个字符串aabcad，请写一段程序，去掉字符串中不相邻的重复字符串，即上述字符串处理之后的输出结果为：aabcd<br>@autoclosure（自动闭包）</li><li>34、iOS app启动如何优化？</li><li>35、swift面试题：</li><li>36、怎样防止反编译？</li><li>37、UITableView性能优化，超实用</li></ul><h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><ul><li>37、 不要阻塞主线程</li><li>38、谈谈你对多线程开发的理解？ios中有几种实现多线程的方法？</li><li>39、进程和线程的区别？同步异步的区别？并行和并发的区别？</li><li>40、ViewController生命周期</li><li>41、iOS 中的多线程</li><li>42、内存管理的几条原则时什么？按照默认法则.那些关键字生成的对象需要手动释放？在和property结合的时候怎样有效的避免内存泄露？谁申请，谁释放</li><li>43、dispatch_barrier_async的作用是什么？</li><li>44、如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</li><li>46、http与https的区别?</li><li>47、服务器能否知道APNS推送后有没有到达客户端的方法？</li><li>48</li><li><ul><li>1.什么方式可以看到上架App的头文件?</li></ul></li><li><ul><li>2.阅读过哪些框架的源码?能说说它的架构方式吗</li></ul></li><li>49、iOS iAP内购审核可能失败的问题</li><li>50、IAP内购中虚拟货币导致审核无法通过的问题？</li></ul><h1 id="群分享"><a href="#群分享" class="headerlink" title="群分享"></a>群分享</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">写一个标准宏 MIN</span><br><span class="line">四中持久化处理方式</span><br><span class="line">OC如何实现多继承 具体怎么做</span><br><span class="line">设计模式有哪些   有什么优缺点</span><br><span class="line">Animation 如何开始 和结束动画的</span><br><span class="line">排序有哪些  有什么优缺点 写出两个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Property 内部操作是怎样的</span><br><span class="line">继承类的实例 isa 指向哪里</span><br><span class="line">Sqlit 事务操作</span><br><span class="line">代码添加约束有哪几种 什么区别</span><br><span class="line">代理在哪里进行了强引用</span><br><span class="line">View 和 layer 设置透明度有什么区别</span><br><span class="line">ViewA 的透明度是 <span class="number">0.5</span> 添加到 ViewB 之后</span><br><span class="line">ViewB 的透明度是多少</span><br><span class="line">Flatbuffer 和 json 传输 区别在哪</span><br><span class="line"></span><br><span class="line">提示操作无效的内存地址报警的过程线程间通信的几种方式和优缺点如何手动触发 kvo 和实现原理View 动画过程中如何获取实时位置、presentationLayer 属性可以获取动画过程中的状态常用的 gcd api 以及作用Sync get main函数前 函数内 函数后各打印一个字母  写出打印顺序Swift中 <span class="class"><span class="keyword">struct</span> <span class="title">class</span> 区别 和分别的应用场景界面有多个动态视图时 <span class="title">Masonry</span> 如何布局</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">各种加密的具体实现以及区别</span></span><br><span class="line"><span class="class"><span class="title">Http</span> 和 <span class="title">https</span> 区别以及内部处理的区别</span></span><br><span class="line"><span class="class"><span class="title">Http</span> 字典请求和图片上传请求的区别</span></span><br><span class="line"><span class="class">包头包含哪些内容</span></span><br><span class="line"><span class="class">又问我网络请求的时候  传进去的字典  内部怎么处理的</span></span><br></pre></td></tr></table></figure><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="Objective-C-weak-的底层实现"><a href="#Objective-C-weak-的底层实现" class="headerlink" title="Objective-C weak 的底层实现"></a>Objective-C weak 的底层实现</h2><blockquote><ul><li>weak的底层实质是Runtime维护了一个weak表（hash表，字典），其key是所指对象的地址，value是一个数组（数组中的元素是weak指针的地址）</li><li>在赋值weak时，实现检查对象地址是否为有效地址（是否是weak指针等），如果有效，系统会使用对象的地址去weak表中获取数组（如果没有就创建数组，同时把数组和对象的地址关联起来）然后把weak指针的地址添加到数组中，其中不会对对象的引用计数做加1操作，在对象回收时使用其地址去weak表中获取数组，同时把数组中的值赋值为nil（所以weak在对象回收时自动置nil），然后清除此键值对。其中具体的操作可以参考<a href="https://www.jianshu.com/p/13c4fb1cedea" target="_blank" rel="noopener">链接1</a> </li><li>疑问1 ：weak对象在由对象1换为对象2时，底层是怎么处理的，待补充</li></ul></blockquote><h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><h3 id="Block是怎么样持有self是"><a href="#Block是怎么样持有self是" class="headerlink" title="Block是怎么样持有self是"></a>Block是怎么样持有self是</h3><blockquote><p>使用block时，其底层是把block相关的代码转换为对象的形式，同时对象会有一个属性持有self，使用如果self持有了block，block底层又会持有self就会导致内存泄露</p></blockquote><h3 id="Block-中为什么不可以访问Block外面的临时C语言数组"><a href="#Block-中为什么不可以访问Block外面的临时C语言数组" class="headerlink" title="Block 中为什么不可以访问Block外面的临时C语言数组"></a>Block 中为什么不可以访问Block外面的临时C语言数组</h3><blockquote><p>是由于C语言的数组操作特性问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2016/11/18/12/14/owl-1834152__340.jpg&quot; alt=&quot;https://cdn.pixabay.com/photo/2016/11/18/12/14/owl-1834152__340.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://liangdahong.com/categories/iOS/"/>
    
    
      <category term="面试" scheme="https://liangdahong.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>2018年计划</title>
    <link href="https://liangdahong.com/2018/01/01/2018/2018%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
    <id>https://liangdahong.com/2018/01/01/2018/2018年计划/</id>
    <published>2018-01-01T15:55:27.000Z</published>
    <updated>2018-08-07T01:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>学习 Web前端 -&gt; 会实现基本的界面。</li><li>在 Web前端 的基础上学习微信小程序 -&gt; 会简单的业务功能开发。</li><li>深耕 iOS 技术，对性能优化，有一点的积累。</li><li>稍微复习下算法。</li><li>加强 Swift 的学习。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;学习 Web前端 -&amp;gt; 会实现基本的界面。&lt;/li&gt;
&lt;li&gt;在 Web前端 的基础上学习微信小程序 -&amp;gt; 会简单的业务功能开发。&lt;/li&gt;
&lt;li&gt;深耕 iOS 技术，对性能优化，有一点的积累。&lt;/li&gt;
&lt;li&gt;稍微复习下算法。&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="吐槽" scheme="https://liangdahong.com/categories/%E5%90%90%E6%A7%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>一些小知识点</title>
    <link href="https://liangdahong.com/2017/12/01/2017/%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://liangdahong.com/2017/12/01/2017/一些小知识点/</id>
    <published>2017-12-01T13:13:00.000Z</published>
    <updated>2018-08-07T09:10:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2016/04/05/11/04/india-1309206__340.jpg" alt="https://cdn.pixabay.com/photo/2016/04/05/11/04/india-1309206__340.jpg"></p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BMerson</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BMerson</span> <span class="title">BMerson</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">BMerson <span class="title">BMersonMake1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> h)</span> </span>&#123;</span><br><span class="line">    BMerson p = &#123;<span class="number">1</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BMerson <span class="title">BMersonMake2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> h)</span> </span>&#123;</span><br><span class="line">    BMerson p = &#123;</span><br><span class="line">        .age = a,</span><br><span class="line">        .height = h,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a1 = <span class="number">0</span>;</span><br><span class="line">    a1 = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, a2);</span><br><span class="line">    <span class="comment">// error a2 = 10;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> a3 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, a3);</span><br><span class="line">    <span class="comment">// error a3 = 10;</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a1;</span><br><span class="line">    <span class="keyword">int</span> *p1;</span><br><span class="line">    p1 = &amp;a1;</span><br><span class="line">    *p1 = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p2;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">    p2 = &amp;a2;</span><br><span class="line">    p2 = &amp;a1;</span><br><span class="line">    <span class="comment">// error  *p2 = 10;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> *p3;</span><br><span class="line">    p3 = &amp;a2;</span><br><span class="line">    p3 = &amp;a1;</span><br><span class="line">    <span class="comment">// error  *p3 = 10;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> p4 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// error  p4 = &amp;a2;</span></span><br><span class="line">    <span class="comment">// error  p4 = &amp;a1;</span></span><br><span class="line">    *p4 = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p5;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p"</span>, p5);</span><br><span class="line">    <span class="comment">// error p5 = &amp;a2;</span></span><br><span class="line">    <span class="comment">// error p5 = &amp;a1;</span></span><br><span class="line">    <span class="comment">// error *p5 = 10;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="iOS中的常量"><a href="#iOS中的常量" class="headerlink" title="iOS中的常量"></a>iOS中的常量</h1><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ul><li>通知名</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN NSNotificationName <span class="keyword">const</span> BMLoginSuccessNotification;</span><br><span class="line"><span class="comment">// NSNotificationName const BMLoginSuccessNotification = @"BMLoginSuccessNotification";</span></span><br><span class="line"><span class="keyword">extern</span> NSNotificationName <span class="keyword">const</span> BMLoginFailureNotification;</span><br><span class="line"><span class="comment">// NSNotificationName const BMLoginFailureNotification = @"BMLoginFailureNotification";</span></span><br></pre></td></tr></table></figure><ul><li>NSString常量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN NSString *<span class="keyword">const</span> BMUserName;</span><br><span class="line"><span class="comment">// NSString *const BMUserName = @"BMUserName";</span></span><br><span class="line"><span class="keyword">extern</span> NSString *<span class="keyword">const</span> BMUserKey;</span><br><span class="line"><span class="comment">// NSString *const BMUserKey = @"BMUserKey";</span></span><br></pre></td></tr></table></figure><ul><li>值常量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN <span class="keyword">const</span> CGFloat BMNavHeight;</span><br><span class="line"><span class="keyword">const</span> CGFloat BMNavHeight = <span class="number">10.0f</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> CGFloat BMNavWidth;</span><br><span class="line"><span class="keyword">const</span> CGFloat BMNavWidth = <span class="number">10.0f</span>;</span><br></pre></td></tr></table></figure><h1 id="Apple-尺寸"><a href="#Apple-尺寸" class="headerlink" title="Apple 尺寸"></a>Apple 尺寸</h1><table><thead><tr><th>设备型号</th><th>屏幕尺寸</th><th>开发尺寸</th><th>像素尺寸</th><th>倍图</th></tr></thead><tbody><tr><td>4/4S</td><td>3.5英寸</td><td>320*480</td><td>640*960</td><td>@2X</td></tr><tr><td>5/5S/5C/SE</td><td>4.0英寸</td><td>320*568</td><td>640*1136</td><td>@2X</td></tr><tr><td>6/6S/7/8</td><td>4.7英寸</td><td>375*667</td><td>750*1134</td><td>@2X</td></tr><tr><td>6P/6SP/7P/8P</td><td>5.5英寸</td><td>414*736</td><td>1242*2208</td><td>@3X</td></tr><tr><td>X</td><td>5.8英寸</td><td>375*812</td><td>1125*2436</td><td>@3X</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>iPad Mini 4 / iPad Air 2 / iPad Pro (9.7)</td><td>9.7英寸</td><td>768*1024</td><td>1536*2048</td><td>@2X</td></tr><tr><td>iPad Pro(12.9) / iPad Pro(12.9) (第二代)</td><td>12.9英寸</td><td>1024*1036</td><td>2048*2732</td><td>@2X</td></tr><tr><td>iPad Pro(10.5)</td><td>10.5英寸</td><td>1112*834</td><td>2224*1668</td><td>@2X</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2016/04/05/11/04/india-1309206__340.jpg&quot; alt=&quot;https://cdn.pixabay.com/photo/2016/04/05/11/04/india-1309206__340.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h1&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://liangdahong.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS事件传递和响应过程</title>
    <link href="https://liangdahong.com/2017/11/28/2017/iOS%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B/"/>
    <id>https://liangdahong.com/2017/11/28/2017/iOS事件传递和响应过程/</id>
    <published>2017-11-28T15:49:27.000Z</published>
    <updated>2018-08-07T09:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/07/31/21/45/sea-2561397__340.jpg" alt="https://cdn.pixabay.com/photo/2017/07/31/21/45/sea-2561397__340.jpg"></p><blockquote><p>我们在平常的开发中肯定经常使用到各种事件，如：button的点击，scrollView的滑动，tableView的Cell的点击等一系列事件，那么他的底层到底是怎么处理的呢？是怎么样传递的，下面会解决以下几个问题。<br><a id="more"></a></p></blockquote><ol><li>为什么子视图超出了其父视图时，超出的部分默认无法触发事件</li><li>为什么父视图关闭事件响应时，其之后的全部视图均无法响应事件</li><li>为什么子视图关闭事件时，我们点击子视图时，事件会触发到其父视图</li><li>…</li></ol><blockquote><p>在iOS系统中事件包括</p></blockquote><ol><li>触屏事件(例如点击按钮、通过手势缩放图片、拖动上下滚动页面等)</li><li>加速计事件(例如摇一摇红包、通过旋转设备控制赛车方向、指南针等)</li><li>远程控制事件(例如耳机的线控、外接手柄、遥控器等)</li></ol><blockquote><p>目前主要研究触摸事件的传递和响应过程</p></blockquote><hr><blockquote><p>在触摸事件的处理过程中会有 事件传递 和 事件响应过程，首先当用户触摸屏幕时，会从上向下</p></blockquote><blockquote><p><code>(UIApplication-&gt;keyWindow-&gt;vc-&gt;View-&gt;View1...)</code></p><p>找到最合适的对象，当找到最合适的View时会由下向上</p></blockquote><blockquote><p><code>(...View1-&gt;keyWindow-&gt; View-&gt; vc-&gt; keyWindow-&gt; UIApplication)</code></p></blockquote><blockquote><p>找最合适响应的对象。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://blog.flight.dev.qunar.com/2016/10/28/ios-event-mechanism-summary/" target="_blank" rel="noopener">http://blog.flight.dev.qunar.com/2016/10/28/ios-event-mechanism-summary/</a></li><li><a href="http://www.jianshu.com/p/2e074db792ba" target="_blank" rel="noopener">http://www.jianshu.com/p/2e074db792ba</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2017/07/31/21/45/sea-2561397__340.jpg&quot; alt=&quot;https://cdn.pixabay.com/photo/2017/07/31/21/45/sea-2561397__340.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们在平常的开发中肯定经常使用到各种事件，如：button的点击，scrollView的滑动，tableView的Cell的点击等一系列事件，那么他的底层到底是怎么处理的呢？是怎么样传递的，下面会解决以下几个问题。&lt;br&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://liangdahong.com/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS第三方库背后的原理和简单使用</title>
    <link href="https://liangdahong.com/2017/11/27/2017/iOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://liangdahong.com/2017/11/27/2017/iOS第三方库背后的原理和简单使用/</id>
    <published>2017-11-27T13:48:03.000Z</published>
    <updated>2018-08-07T09:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2018/01/16/23/37/sunset-3087145__340.jpg" alt="https://cdn.pixabay.com/photo/2018/01/16/23/37/sunset-3087145__340.jpg"></p><blockquote><p>在我们平时的开发中，或多或少都会使用到一些开源库，在小公司甚至大量依赖第三方，那么我们对一些知名第三方是否有必要了解下它背后的原理呢，甚至应该阅读一些知名第三方的底层实现和原理，下面就简单介绍一些第三方的实现原理和简单的使用方法吧。</p></blockquote><a id="more"></a><h1 id="MJExtension"><a href="#MJExtension" class="headerlink" title="MJExtension"></a>MJExtension</h1><blockquote><p><a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="noopener">MJExtension</a></p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="json-gt-Model"><a href="#json-gt-Model" class="headerlink" title="json -&gt; Model"></a>json -&gt; Model</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json -&gt; Model </span></span><br><span class="line">+ (instancetype)mj_objectWithKeyValues:(id)keyValues;</span><br><span class="line"></span><br><span class="line"><span class="comment">// json -&gt; Model 数组</span></span><br><span class="line">+ (NSMutableArray *)mj_objectArrayWithKeyValuesArray:(NSArray *)keyValuesArray;</span><br></pre></td></tr></table></figure><h3 id="Model-gt-json"><a href="#Model-gt-json" class="headerlink" title="Model -&gt; json"></a>Model -&gt; json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  转换为JSON Data</span><br><span class="line"> */</span><br><span class="line">- (NSData *)mj_JSONData;</span><br><span class="line">/**</span><br><span class="line"> *  转换为字典或者数组</span><br><span class="line"> */</span><br><span class="line">- (id)mj_JSONObject;</span><br><span class="line">/**</span><br><span class="line"> *  转换为JSON 字符串</span><br><span class="line"> */</span><br><span class="line">- (NSString *)mj_JSONString;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数组中需要转换的模型*/</span></span><br><span class="line">+ (NSDictionary *)mj_objectClassInArray&#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">             @<span class="string">"array1"</span>: BMImageInfoModel.class,</span><br><span class="line">             &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*key 重命名 服务器key : 模型属性key */</span></span><br><span class="line">+ (NSDictionary *)mj_replacedKeyFromPropertyName &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">             @<span class="string">"description"</span>: @<span class="string">"desc"</span>,</span><br><span class="line">             @<span class="string">"id"</span>: @<span class="string">"ID"</span>,</span><br><span class="line">             &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*json -&gt; Model 完成时*/</span></span><br><span class="line">- (<span class="keyword">void</span>)mj_keyValuesDidFinishConvertingToObject &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Model -&gt; json 完成时*/</span></span><br><span class="line">- (<span class="keyword">void</span>)mj_objectDidFinishConvertingToKeyValues &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li><p>我们知道 json-&gt;Model时，其实就是在dict中取对应的值然后设置到Model中，  <code>obj.name = dict[@&quot;name&quot;];</code>   我们知道Model中的属性一般是非常多的，而且一个项目中Model也是非常多，而且Model中的属性随时可能变动，像上面的赋值代码就会成千上万，而且非常不好维护，那么我们有没有快捷的方法解决好这些问题呢？<a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="noopener">MJExtension</a>就是为我们解决了这些问题的一个库而且可以扩展许多功能。不管你有多少属性只需要<code>mj_objectWithKeyValues</code>这样一行代码完美搞定。</p></li><li><p>在上面的分析中我们肯定要想办法动态的获取Model中的属性，同时去dict中取相应的值设置给Model相应的属性，其实<a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="noopener">MJExtension</a>的核心功能就是解决这个问题，<a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="noopener">MJExtension</a>使用Runtime动态地的获取模型的属性，然后动态的在dict中取相应的值设置给Model，当然其中做了特别多的优化和扩展。</p></li><li><p>动态获取模型的属性</p></li></ol><blockquote><p>NSObject+MJKeyValue.m 文件 87 行的如下代码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[clazz mj_enumerateProperties:^(MJProperty *property, BOOL *stop)...</span><br></pre></td></tr></table></figure><ol><li>使用KVC赋值</li></ol><blockquote><p>NSObject+MJKeyValue.m 文件 189 行的如下代码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.赋值</span></span><br><span class="line">[property setValue:value forObject:self];</span><br></pre></td></tr></table></figure><p>此方法内部如下（NSObject+MJKeyValue.m 文件78行）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  设置成员变量的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(id)value forObject:(id)object</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.type.KVCDisabled || value == nil) <span class="keyword">return</span>;</span><br><span class="line">    [object setValue:value forKey:self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>基本功能的代码基本就是上面的代码段，当然有大量的优化和扩展防错等功能未展开。</p></blockquote><ol><li>支持模型的继承属性，比如：Model的父类有一个name属性，那么在转换时会支持name属性的获取</li><li>对一些特殊类型做了特殊处理，比如：BOOL类型等</li><li>支持模型嵌套模型转换</li><li>支持模型嵌套数组转换，如果数组中的对象是模型需实现相应协议</li><li>支持指定属性名称支持转换和指定属性名称不支持转换</li><li>只对属性有效</li><li>支持readonly属性</li><li>对Model的属性做了缓存大幅度增加性能</li><li>添加一些扩展方法，Model-&gt;jsonData, Model-&gt;json, Model-&gt;dict</li><li>json(NSData dict，NSString)-&gt;模型 </li><li>json(NSData arr，NSString)-&gt;模型数组 </li><li>获取到模型的属性列表时做缓存</li><li>内部使用KVC赋值</li></ol><h1 id="YYModel"><a href="#YYModel" class="headerlink" title="YYModel"></a>YYModel</h1><h1 id="YYCache"><a href="#YYCache" class="headerlink" title="YYCache"></a>YYCache</h1><h1 id="UITableView-FDTemplateLayoutCell"><a href="#UITableView-FDTemplateLayoutCell" class="headerlink" title="UITableView-FDTemplateLayoutCell"></a>UITableView-FDTemplateLayoutCell</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2018/01/16/23/37/sunset-3087145__340.jpg&quot; alt=&quot;https://cdn.pixabay.com/photo/2018/01/16/23/37/sunset-3087145__340.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在我们平时的开发中，或多或少都会使用到一些开源库，在小公司甚至大量依赖第三方，那么我们对一些知名第三方是否有必要了解下它背后的原理呢，甚至应该阅读一些知名第三方的底层实现和原理，下面就简单介绍一些第三方的实现原理和简单的使用方法吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://liangdahong.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS开发之GCD详解</title>
    <link href="https://liangdahong.com/2017/10/30/2017/iOS%E5%BC%80%E5%8F%91%E4%B9%8BGCD%E8%AF%A6%E8%A7%A3/"/>
    <id>https://liangdahong.com/2017/10/30/2017/iOS开发之GCD详解/</id>
    <published>2017-10-30T14:30:06.000Z</published>
    <updated>2018-08-07T09:11:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列-dispatch-queue-t"><a href="#队列-dispatch-queue-t" class="headerlink" title="队列 dispatch_queue_t"></a>队列 dispatch_queue_t</h1><h2 id="并行队列"><a href="#并行队列" class="headerlink" title="并行队列"></a>并行队列</h2><blockquote><p>其任务是随机顺序执行，完全由系统处理。</p></blockquote><ul><li>全局并行队列<a id="more"></a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>自定义创建并行队列</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_create(<span class="string">"com.idhong.concurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><h2 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h2><blockquote><p>其任务是按照先后顺序执行</p></blockquote><ul><li>全局串行队列 (主线程队列)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_get_main_queue();</span><br></pre></td></tr></table></figure><ul><li>自定义创建串行队列</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_create(<span class="string">"com.idhong.concurrentQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_create(<span class="string">"com.idhong.concurrentQueue"</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><blockquote><p>队列可以理解为对任务的管理，对任务使用 <code>串行(先后顺序执行)</code>还是<code>并行（随机执行，由系统确定）</code>处理。</p></blockquote><h1 id="异步执行-amp-同步执行"><a href="#异步执行-amp-同步执行" class="headerlink" title="异步执行&amp;同步执行"></a>异步执行&amp;同步执行</h1><h2 id="dispatch-async"><a href="#dispatch-async" class="headerlink" title="dispatch_async"></a>dispatch_async</h2><blockquote><p>默认会开启新线程执行传入的队列，会立即返回。</p></blockquote><h2 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a>dispatch_sync</h2><blockquote><p>在当前线程执行传入的队列，执行完才返回。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>当前的线程在主线程中执行时会导致死锁，dispatch_sync 操作会让传如的队列在当前线程执行，而且必须执行完才返回，dispatch_get_main_queue()又是串行队列，是先进先出，（先后顺序执行）必须要让先加入 dispatch_get_main_queue() 中的任务执行完毕执行（外面的代码），从而导致相互等待导致死锁。</p></blockquote><ul><li><code>串行队列a</code> 中 <code>同步执行dispatch_sync</code> <code>串行队列a</code> 的任务会导致<code>死锁</code></li></ul><h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;队列-dispatch-queue-t&quot;&gt;&lt;a href=&quot;#队列-dispatch-queue-t&quot; class=&quot;headerlink&quot; title=&quot;队列 dispatch_queue_t&quot;&gt;&lt;/a&gt;队列 dispatch_queue_t&lt;/h1&gt;&lt;h2 id=&quot;并行队列&quot;&gt;&lt;a href=&quot;#并行队列&quot; class=&quot;headerlink&quot; title=&quot;并行队列&quot;&gt;&lt;/a&gt;并行队列&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;其任务是随机顺序执行，完全由系统处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;全局并行队列
    
    </summary>
    
      <category term="iOS" scheme="https://liangdahong.com/categories/iOS/"/>
    
    
      <category term="GCD" scheme="https://liangdahong.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>浅谈计算机内存分配</title>
    <link href="https://liangdahong.com/2017/10/16/2017/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://liangdahong.com/2017/10/16/2017/浅谈计算机内存分配/</id>
    <published>2017-10-16T15:05:25.000Z</published>
    <updated>2018-08-07T09:10:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><table><thead><tr><th>名称</th><th>内容</th><th>特性</th></tr></thead><tbody><tr><td>栈区（stack）</td><td></td><td>栈区（stack）由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。后进先出（LIFO）；栈是逆向生长，先进栈的所分配的内存空间地址更大。</td></tr><tr><td>堆区（heap）</td><td></td><td>堆区（heap）一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。先进先出（FIFO）；堆是顺序生长，先进栈的所分配的内存空间地址更小。</td></tr><tr><td>数据区</td><td>全局非静态区、全局静态区、局部静态区、常量区</td><td>数据区主要包括静态全局区和常量区，如果要站在汇编角度细分的话还可以分为很多小的区； 数据区全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后有系统释放；常量字符串就是放在常量区。程序结束后由系统释放。</td></tr></tbody></table><p><code>注：对于指针指向的所分配的某一块内存（无论是堆还是栈）的首地址永远是这块内存中最小的。</code></p><a id="more"></a><h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><table><thead><tr><th>名称</th><th>内容</th><th>特性</th></tr></thead><tbody><tr><td>栈区（stack）</td><td></td><td>存放的局部变量、先进后出、一旦出了作用域就会被销毁；函数跳转地址，现场保护等；程序猿不需要管理栈区变量的内存；栈区地址从高到低分配。</td></tr><tr><td>堆区（heap）</td><td>全局区非静态区、全局静态区、局部静态区</td><td>堆区的内存分配使用的是alloc；需要程序猿管理内存；ARC的内存的管理，是编译器再编译的时候自动添加retain、release、autorelease；堆区的地址是从低到高分配。</td></tr><tr><td>全局区/静态区（static）</td><td></td><td>全局区/静态区（static）包括两个部分：未初始化过 、初始化过；也就是说，（全局区/静态区）在内存中是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域；eg：int a;未初始化的。int a = 10;已初始化的。</td></tr><tr><td>常量区</td><td></td><td>常量字符串就是放在常量区。</td></tr><tr><td>代码区</td><td></td><td>代码区存放App二进制代码。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C语言&quot;&gt;&lt;a href=&quot;#C语言&quot; class=&quot;headerlink&quot; title=&quot;C语言&quot;&gt;&lt;/a&gt;C语言&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;栈区（stack）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;栈区（stack）由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。后进先出（LIFO）；栈是逆向生长，先进栈的所分配的内存空间地址更大。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;堆区（heap）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;堆区（heap）一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。先进先出（FIFO）；堆是顺序生长，先进栈的所分配的内存空间地址更小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据区&lt;/td&gt;
&lt;td&gt;全局非静态区、全局静态区、局部静态区、常量区&lt;/td&gt;
&lt;td&gt;数据区主要包括静态全局区和常量区，如果要站在汇编角度细分的话还可以分为很多小的区； 数据区全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后有系统释放；常量字符串就是放在常量区。程序结束后由系统释放。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;注：对于指针指向的所分配的某一块内存（无论是堆还是栈）的首地址永远是这块内存中最小的。&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://liangdahong.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机存储单位和带宽等的关系</title>
    <link href="https://liangdahong.com/2017/10/15/2017/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E5%92%8C%E5%B8%A6%E5%AE%BD%E7%AD%89%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://liangdahong.com/2017/10/15/2017/计算机存储单位和带宽等的关系/</id>
    <published>2017-10-15T09:06:25.000Z</published>
    <updated>2018-08-07T01:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机存储单位"><a href="#计算机存储单位" class="headerlink" title="计算机存储单位"></a>计算机存储单位</h2><ul><li>计算机存储信息的最小单位是：<code>位/bit (比特/Binary Digits)</code>存放一位二进制数，即 <code>0</code> 或 <code>1</code>，是最小的存储单位。</li><li>计算机存储容量基本单位是：<code>字节/B (byte)</code>, <code>8个二进制位</code>为一个<code>字节(B)</code>，计算机中最常用的单位。 </li><li>计算机的存储单位有：<code>b，B，KB，MB，GB，TB，PB，EB，ZB，YB，BB</code>等。<a id="more"></a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1B</span> (Byte 字节)                   = <span class="number">8b</span>it（比特，位）</span><br><span class="line"><span class="number">1</span>KB (Kilobyte 千字节)            = <span class="number">1024B</span>（<span class="number">1024</span>=<span class="number">2</span>^<span class="number">10</span>）</span><br><span class="line"><span class="number">1</span>MB (Megabyte 兆字节 简称“兆”)    = <span class="number">1024</span>KB</span><br><span class="line"><span class="number">1</span>GB (Gigabyte 吉字节 又称“千兆”)   = <span class="number">1024</span>MB</span><br><span class="line"><span class="number">1</span>TB (Trillionbyte 万亿字节 太字节) = <span class="number">1024</span>GB</span><br><span class="line"><span class="number">1</span>PB（Petabyte 千万亿字节 拍字节）   = <span class="number">1024</span>TB</span><br><span class="line"><span class="number">1</span>EB（Exabyte 百亿亿字节 艾字节）    = <span class="number">1024</span>PB</span><br><span class="line"><span class="number">1</span>ZB (Zettabyte 十万亿亿字节 泽字节) = <span class="number">1024</span> EB</span><br><span class="line"><span class="number">1</span>YB (Yottabyte 一亿亿亿字节 尧字节) = <span class="number">1024</span> ZB</span><br><span class="line"><span class="number">1B</span>B (Brontobyte 一千亿亿亿字节)    = <span class="number">1024</span> YB.</span><br></pre></td></tr></table></figure><blockquote><p>在我们的平时开发中，经常说一个英文字母占1个字节（<code>8bit/8个二进制位）</code><br>int 类型占<code>4/8个字节（32bit/64bit）</code>，所以可表示的数字范围就可以由其占的二进制位数来确定，当然要考虑正负数，符号等。</p></blockquote><h2 id="宽带时使用的单位"><a href="#宽带时使用的单位" class="headerlink" title="宽带时使用的单位"></a>宽带时使用的单位</h2><blockquote><p>我们在牵宽带时，经常会接触到<code>2M/4M/8M</code>等，但是比如我们牵的2M带宽为什么往往在下载时下载速度在<code>200KB/s</code>左右徘徊，而不是<code>2M/s</code>呢？</p></blockquote><ul><li>网络带宽中的2M带宽表示<code>2Mbps/s (2x1024x1024bit/s)</code> ，<code>bps</code>表示<code>bit（位）</code></li><li>但在存储中<code>2M（2x1024x1024x8bit）</code>,这里使用的最基本单位不同，相差<code>8倍</code></li><li>所以2M带宽的标准下载速度应该是</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span>x1024x1024bit/s)/<span class="number">8</span>）= <span class="number">256</span>x1024bit/s = <span class="number">256</span>KB/s</span><br></pre></td></tr></table></figure><p>当然会加上一些其他的损耗就在<code>200KB/s</code>左右浮动了。</p><h2 id="厂商的硬盘存储单位"><a href="#厂商的硬盘存储单位" class="headerlink" title="厂商的硬盘存储单位"></a>厂商的硬盘存储单位</h2><blockquote><p>在好久之前可能我们都买给内存卡，硬盘等。买一个<code>1G</code>的内存卡往往只有大概<code>930M</code>左右的存储容量，why？难道是奸商，其实不是的，是他们计算方式不一样。我们都知道对计算机来说，它早知道二进制<code>(010101)</code>，但我们人类使用的基本是10进制，厂商使用的是10进制来计算了。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 厂商的计算方式</span></span><br><span class="line"><span class="number">1</span>G = <span class="number">1</span> x <span class="number">1000</span> x <span class="number">1000</span> x <span class="number">1000</span> x <span class="number">8</span> bit = <span class="number">8</span> <span class="number">000</span> <span class="number">000</span> <span class="number">000</span> bit</span><br><span class="line"><span class="comment">// 计算机的计算方式</span></span><br><span class="line"><span class="number">1</span>G = <span class="number">1</span> x <span class="number">1024</span> x <span class="number">1024</span> x <span class="number">1024</span> x <span class="number">8</span> bit</span><br></pre></td></tr></table></figure><p>所以厂商的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>G =  <span class="number">1</span>G x （（<span class="number">1000</span>x1000x1000）/ (<span class="number">1024</span>x1024x1024 )) = <span class="number">0.931</span>G 左右。</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://xlnb.iteye.com/blog/842820" target="_blank" rel="noopener">http://xlnb.iteye.com/blog/842820</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机存储单位&quot;&gt;&lt;a href=&quot;#计算机存储单位&quot; class=&quot;headerlink&quot; title=&quot;计算机存储单位&quot;&gt;&lt;/a&gt;计算机存储单位&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计算机存储信息的最小单位是：&lt;code&gt;位/bit (比特/Binary Digits)&lt;/code&gt;存放一位二进制数，即 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt;，是最小的存储单位。&lt;/li&gt;
&lt;li&gt;计算机存储容量基本单位是：&lt;code&gt;字节/B (byte)&lt;/code&gt;, &lt;code&gt;8个二进制位&lt;/code&gt;为一个&lt;code&gt;字节(B)&lt;/code&gt;，计算机中最常用的单位。 &lt;/li&gt;
&lt;li&gt;计算机的存储单位有：&lt;code&gt;b，B，KB，MB，GB，TB，PB，EB，ZB，YB，BB&lt;/code&gt;等。
    
    </summary>
    
      <category term="计算机基础" scheme="https://liangdahong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>OC中mutableCopy及copy与NSString和集合类</title>
    <link href="https://liangdahong.com/2017/10/12/2017/OC%E4%B8%ADmutableCopy%E5%8F%8Acopy%E4%B8%8ENSString%E5%92%8C%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <id>https://liangdahong.com/2017/10/12/2017/OC中mutableCopy及copy与NSString和集合类/</id>
    <published>2017-10-12T14:53:35.000Z</published>
    <updated>2018-08-07T09:12:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote><p>在<code>iOS</code>开发中可能有时候会接触到<code>copy</code>和<code>mutableCopy</code>这两个方法，而且其相关的内存问题经常出没于面试题中，本文简单介绍下<code>mutableCopy</code>及<code>copy</code>与<code>NSString</code>和集合类的相关问题。<br><a id="more"></a></p></blockquote><h1 id="copy-mutableCopy对NSString操作"><a href="#copy-mutableCopy对NSString操作" class="headerlink" title="copy, mutableCopy对NSString操作"></a>copy, mutableCopy对NSString操作</h1><blockquote><p>在对<code>NSString</code>进行<code>copy</code>或者<code>mutableCopy</code>操作时可以使用下图的内存分配情况来表述</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/2026898-f5e1413d3ba93a5a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未命名.001.jpeg"></p><p><img src="http://upload-images.jianshu.io/upload_images/2026898-f5e1413d3ba93a5a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未命名.002.jpeg"></p><blockquote><p>由上可得，</p></blockquote><ul><li><code>copy</code> 对 <code>NSString</code> 是浅拷贝，只拷贝指针 </li><li><code>mutableCopy 对</code>NSString`是深拷贝，拷贝指针及内容</li><li><code>copy 对</code>NSMutableString` 是深拷贝，拷贝指针及内容</li><li><code>mutableCopy</code> 对 <code>NSMutableString</code> 是深拷贝，拷贝指针及内容</li></ul><h1 id="copy-mutableCopy对NSArray操作"><a href="#copy-mutableCopy对NSArray操作" class="headerlink" title="copy, mutableCopy对NSArray操作"></a>copy, mutableCopy对NSArray操作</h1><blockquote><p>在对<code>NSArray</code>进行<code>copy</code>或者<code>mutableCopy</code>操作时可以使用下图的内存分配情况来表述</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/2026898-9357257c0e0357c0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未命名1.001.jpeg"></p><p><img src="http://upload-images.jianshu.io/upload_images/2026898-187f3e5960d11614.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未命名1.002.jpeg"></p><blockquote><p>由上面的图可以得到和<code>NSString</code>一致的答案。</p></blockquote><h1 id="copy-mutableCopy对NSDictionary操作"><a href="#copy-mutableCopy对NSDictionary操作" class="headerlink" title="copy, mutableCopy对NSDictionary操作"></a>copy, mutableCopy对NSDictionary操作</h1><blockquote><p>基本同<code>copy</code>, <code>mutableCopy</code>对<code>NSArray</code>操作</p></blockquote><h1 id="copy-mutableCopy对NSSet操作"><a href="#copy-mutableCopy对NSSet操作" class="headerlink" title="copy, mutableCopy对NSSet操作"></a>copy, mutableCopy对NSSet操作</h1><blockquote><p>基本同<code>copy</code>, <code>mutableCopy</code>对<code>NSArray</code>操作</p></blockquote><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote><p>由上面的内存分配情况可得</p></blockquote><ul><li><code>copy</code> 对 不可变类型是浅拷贝</li><li><code>copy</code> 对 可变类型是深拷贝</li><li><code>mutableCopy</code> 对 不可变类型是深拷贝</li><li><code>mutableCopy</code>对 可变类型`深拷贝</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在&lt;code&gt;iOS&lt;/code&gt;开发中可能有时候会接触到&lt;code&gt;copy&lt;/code&gt;和&lt;code&gt;mutableCopy&lt;/code&gt;这两个方法，而且其相关的内存问题经常出没于面试题中，本文简单介绍下&lt;code&gt;mutableCopy&lt;/code&gt;及&lt;code&gt;copy&lt;/code&gt;与&lt;code&gt;NSString&lt;/code&gt;和集合类的相关问题。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://liangdahong.com/categories/iOS/"/>
    
    
  </entry>
  
</feed>
